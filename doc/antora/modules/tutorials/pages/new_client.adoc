= Adding a new client to the server

*Goal:* To permit an additional RADIUS client to communicate with the
server.

*Time:* 5-10 minutes.

*File:*

- `etc/raddb/clients.conf`

The RADIUS server will only communicate with known clients. This
restriction is for security, so that unknown machines on the Internet
cannot probe the RADIUS server with test packets.

In FreeRADIUS, the `clients.conf` file lists the clients that are
permitted to send requests to the server. Take some time to read this file and
the included comments.

== Configure the server

Configure the server by adding the new client's IP address and shared secret just below `client localhost`. If the server is already running, stop it.

[source,bash]
----
client new_client {
    ipaddr = 192.168.1.100
    secret = StrongSecretHere
    proto = udp
    require_message_authenticator = auto
    limit_proxy_state = auto
    limit {
        max_connections = 16
        lifetime = 0
        idle_timeout = 30
    }
    shortname = new_client
}
----

Each client must have a single IP address and a shared secret. Only one of `ipaddr`, `ipv4addr`, or `ipv6addr` can be used. The `ipaddr` attribute defines the client's IP address and can be IPv4, IPv6, or a domain name, though using an IP is recommended. For example, `ipaddr = 127.0.0.1` refers to the local machine. `ipv4addr` allows only IPv4 addresses, with `*` permitting any IPv4. `ipv6addr` allows only IPv6 addresses, with `::1` for localhost. Using explicit IP addresses avoids DNS lookup issues, as the server resolves hostnames only once at startup.

The `secret` is a shared password used to secure communication between the client and the server. It can be any string up to 8k characters and should be random and strong to prevent unauthorized access.

Other optional settings can be added to control how the client connects and communicates with the server. These include: `proto`, `require_message_authenticator`, `limit_proxy_state`, `shortname`, and `limit`.

The `proto` attribute specifies the transport protocol used by the client. It can be `udp`, `tcp`, or `*` for both. If not set, it defaults to `udp`, which is the standard RADIUS protocol. TCP is used for clients that require reliable connections.

`require_message_authenticator` ensures that a `Message-Authenticator` is included in `Access-Request` packets. Its values can be `yes`, `no`, or `auto` (default). Setting it to `yes` enhances security by verifying the integrity of requests.

`limit_proxy_state` controls whether `Proxy-State` attributes are accepted in packets that do not include a `Message-Authenticator`. Allowed values are `yes`, `no`, or `auto` (default is `auto`). This helps prevent attacks by ensuring only valid packets are processed.

The `shortname` attribute provides a simple alias for the client's full domain name or IP address. It is optional and primarily used for compatibility with older versions of FreeRADIUS.

The `limit` section defines connection limits for TCP clients. `max_connections` sets the maximum simultaneous TCP connections (default 16; 0 means no limit). `lifetime` sets the duration in seconds before a connection closes (0 means unlimited). `idle_timeout` defines the time in seconds a connection can remain idle before being closed (0 means no timeout; default 30). These limits help manage server load and prevent resource exhaustion.


== Start the server

[source, bash]
----
$ radiusd -X
----

== Verify the configuration

Send a `Status-Server` packet from the new client to the server, using the correct IP address, port, and shared secret.

Verify that the server saw the packet. Also verify that the client saw the response.

### Common Problems

Some common problems are:

* Not using the correct port in the client software.
* Not using the correct shared secret in the client software.
* The server responds to the client from an address that is different from the one to which the client sent the request.

The first two problems can be solved by configuring the client with the correct information. The last problem is seen when the client does not see the response from the server, or when the server gives an error message about an invalid response.

If the server responds to the packet and the client accepts the response, then the test was successful, and the server may be halted.

== Questions

1.  What happens when the server receives a packet from a machine not
listed in "clients.conf"?
2.  Why does the client not accept the response from the server when
that response originates from another IP address?
3.  Why does the server have to be re-started when the "clients.conf"
file is edited?
4.  What are the other fields in a client entry, and what are they used
for?

// Copyright (C) 2021 Network RADIUS SAS.  Licenced under CC-by-NC 4.0.
// This documentation was developed by Network RADIUS SAS.
