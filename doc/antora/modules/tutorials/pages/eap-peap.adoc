= EAP-PEAP: Tunneled Authentication

*Goal:* Configure the FreeRADIUS server to authenticate users using EAP-PEAP, then verify it works by sending and receiving test packets.

*Time:* 20–35 minutes.

*Files:*

- `mods-available/eap` — controls which EAP methods are enabled
- `mods-config/files/authorize` — the flat file where test users like `bob` are defined
- `sites-available/inner-tunnel` — the virtual server that handles Phase 2 authentication and looks up the user
- `eapol_test/peap-mschapv2.conf` — configuration for the test client

== What is EAP-PEAP?

EAP-PEAP protects user credentials by wrapping the login exchange inside an encrypted TLS tunnel. Think of it like sending a letter inside a locked box — even if someone intercepts it, they cannot read what is inside.

*Diagram:*

image::peap_packet.svg[Fig. PEAP Packet]

** *Phase 1* — The server presents its TLS certificate and a secure encrypted tunnel is created between the client and the server. At this point, only the anonymous identity (e.g. `anonymous@example.org`) is visible on the network. The real username is hidden.
** *Phase 2* — Inside that tunnel, the client sends the real username and password using EAP-MSCHAPv2. The server then looks up the user in its user database, checks the password, and either accepts or rejects the request.

The main advantage over EAP-TLS is that the *client does not need a certificate* — only the server does. This makes deployment much simpler in large environments.

== How the User `bob` is Recognised

Understanding where `bob` gets looked up helps you troubleshoot problems and extend the configuration later.

When a PEAP authentication request arrives, FreeRADIUS processes it in two separate stages:

*Stage 1 — Outer request (Phase 1):*
The server only sees the anonymous identity (e.g. `anonymous@example.org`). This is handled by the default virtual server in `sites-available/default`. No user lookup happens here — the server simply establishes the TLS tunnel and passes control to Stage 2.

*Stage 2 — Inner tunnel request (Phase 2):*
Once the TLS tunnel is established, the real username `bob` is decrypted from inside the tunnel. This inner request is handled by a separate virtual server defined in `sites-available/inner-tunnel`.

Inside the inner-tunnel virtual server, FreeRADIUS runs through the `authorize` section, which calls the `files` module. The `files` module reads `mods-config/files/authorize` line by line, looking for a matching username. When it finds `bob`, it retrieves the stored password and passes it to the `mschapv2` module for verification.

== Before You Begin

** FreeRADIUS automatically generates the server certificates needed for PEAP when it first starts. You do not need to create them manually.
** You need both the `mschap` module and the `mschapv2` module enabled. The `mschap` module handles MSCHAP authentication in general, while `mschapv2` specifically handles the EAP-MSCHAPv2 exchange inside the PEAP tunnel. Both are required.
** Make sure the `inner-tunnel` virtual server is enabled. This is what processes the real username and password inside the tunnel.

== Step 1: Create the Test User

Open `raddb/mods-config/files/authorize` and add the following line:

[source, text]
----
bob    Password.Cleartext := "hello"
----

== Step 2: Verify the `sites-enabled/default`

Verify the following entry added.

[source, text]
----
authenticate mschap {
	mschap
}
----

This tells FreeRADIUS that when a request arrives for user `bob` inside the inner tunnel, the expected cleartext password is `hello`. The `files` module reads this file top to bottom and stops at the first match. If you have multiple users, each goes on its own line.

== Step 3: Verify the Inner Tunnel Virtual Server

Open `sites-available/inner-tunnel` and confirm the `authorize` and `authenticate` sections look like this:

[source, text]
----
recv Access-Request {
	mschap

	eap {
		ok = return
	}
	files
}
----

The `files` entry in `authorize` is what triggers the lookup of `bob` in `mods-config/files/authorize`. If `files` is missing here, the server will never find the user and authentication will always fail.

Ensure the inner-tunnel site is enabled by checking that the symlink exists:

[source, bash]
----
$ ls sites-enabled/inner-tunnel
----

If it does not exist, create it:

[source, bash]
----
$ ln -s ../sites-available/inner-tunnel sites-enabled/inner-tunnel
----

== Step 4: Configure the Test Client

Open `src/tests/eapol_test/peap-mschapv2.conf` and update it with the following:

[source, text]
----
network={
	ssid="example"
	key_mgmt=WPA-EAP
	eap=PEAP
	identity="bob@example.org"
	anonymous_identity="anonymous@example.org"
	password="hello"
	phase2="auth=MSCHAPV2"
	phase1="peapver=0"
}
----

Notice that both `identity` and `anonymous_identity` are set. The `anonymous_identity` is what gets sent in Phase 1 and is visible on the network. The real `identity` (`bob`) is only sent inside the encrypted tunnel in Phase 2. The server looks up `bob` — not `anonymous@example.org` — when checking the password.

== Step 5: Start the Server

Start FreeRADIUS in debug mode so you can watch every step of the authentication:

[source, text]
----
$ radiusd -X
----

== Step 6: Run the Test

Open a second terminal and run:

[source, bash]
----
./eapol_test -c peap-mschapv2.conf -a 127.0.0.1 -p 1812 -s testing123 -n
----







== Questions

1.  How does EAP-PEAP compare with EAP-TTLS?
2.  What authentication protocols may be carried inside of the TLS
tunnel for EAP-PEAP?
3.  Would you use EAP-PEAP in a large deployment? If so, why? If not,
why not?

// Copyright (C) 2021 Network RADIUS SAS.  Licenced under CC-by-NC 4.0.
// This documentation was developed by Network RADIUS SAS.
