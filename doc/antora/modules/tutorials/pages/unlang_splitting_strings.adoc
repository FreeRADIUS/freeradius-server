= Splitting strings

*Goal:* Explore uses of regular expressions and subcapture groups
*Time:* 10-20 minutes

*File:*
- `etc/raddb/policy.d/*`

*`man` page:* `unlang`

*documentation page(s):*

- xref:reference:unlang/condition/index.adoc[Conditions]
- xref:reference:unlang/condition/regex.adoc[Regular expressions]
- xref:reference:unlang/index.adoc[Unlang]


For this tutorial you should start with an empty authorization section:

[source,unlang]
----
recv Access-Request {
    # We'll include our policy in here
}
----

in the virtual server you’re using to process requests.

== Common control attributes
Attributes in the control list can control the behaviour of the server.
Commonly used control attributes are:

* `control.Auth-Type` specifies the `authenticate <name> {}` section to run

Regular expressions are an extremely powerful tool in the 'unlang' policy language.
They provide both validation capabilities, allowing users to check the format of
incoming attributes, and substring extraction (via capture groups).

If you’ve completed the xref:proxy.adoc[Proxy] exercise you’ll have used the `suffix` module to
split an incoming `User-Name` value into its components and setup the request for
proxying.

**Task:**
Create an unlang version of "suffix" that splits an incoming `User-Name` into two
components on the "@" separator.

The first component should be written to the `request.Stripped-User-Name` attribute
and the second component should be written to the `control.Stripped-User-Domain`
attribute.

Use `bob@realm1.com` and `bob@realm2.com` to test your new policy to ensure it works
as expected.

If you’ve completed the xref:proxy.adoc[Proxy] tutorial and have test realms setup, modify the
policy code you have just written to proxy the request to the realm specified
in the `User-Name` attribute.

== Step 1 – Basic splitting policy

[source,unlang]
.FILE: /etc/raddb/policy.d/realm-split
----
realm-split {
    # Check if User-Name exists and contains an "@" symbol
    if (request.User-Name =~ /^([^@]+)@(.+)$/) {
        # First capture group - username part (before @)
        request.Stripped-User-Name := %regex.match(1)

        # Second capture group - domain/realm part (after @)
        control.Stripped-User-Domain := %regex.match(2)

        # IMPORTANT: Override User-Name with just the username part
        # This allows the users file to match on "bob" instead of "bob@realm1.com"
        request.User-Name := request.Stripped-User-Name

        # Add reply attributes to validate the split worked correctly
        # Using Reply-Message to show both values (visible in reply)
        reply += {
            Reply-Message = "User: %{request.Stripped-User-Name}"
            Reply-Message = "Domain: %{control.Stripped-User-Domain}"
        }
    }
}
----

Add the above created policy into `raddb/sites-available/default`:

[source,unlang]
----
server default {
    recv Access-Request {
        realm_split
        files
    }
}
----

Also make sure our testing user "bob" exists in `raddb/mods-config/files/authorize`:

[source,text]
----
bob     Password.Cleartext := "hello"
----

== Questions

1.  Regular expressions can contain attribute expansions.  Given that
    all supported regular expression libraries support pre-compilation
    of expressions, why would regular expressions containing expansions
    be avoided when the server being deployed will be under heavy load?
2.  Why might you want to re-implement functionality offered by modules
    in unlang?
3.  What is an advantage of using expression based string splitting
    over the suffix module?

// Copyright (C) 2021 Network RADIUS SAS.  Licenced under CC-by-NC 4.0.
// This documentation was developed by Network RADIUS SAS.
