= Communicating with an SQL database

*Goal:* Configure the server so that it can communicate with an SQL database and retrieve user authentication and authorisation information directly from that database instead of (or in addition to) the flat `authorize` file.

*Time:* 25–45 minutes

*Files you will need to look at or edit:*

- `mods-available/sql`
- `mods-config/sql/main/<dialect>/schema.sql`
- `mods-config/sql/main/<dialect>/queries.conf`
- `sites-enabled/default`

Many sites start with user information stored in the classic `authorize` file because it is simple and quick to edit. However, once the number of authorize grows into the thousands — or especially into the tens or hundreds of thousands — maintaining that file becomes impractical. Flat files do not offer fast indexed lookups, concurrent writes from multiple tools become dangerous, and most network management systems or billing platforms cannot easily update a text file safely.

This is where SQL databases become very attractive. Modern relational databases are designed to handle millions of records, provide extremely fast indexed searches, support transactions, allow many different applications to read and write data safely, and come with a huge ecosystem of management tools, backup solutions, replication options, and monitoring integrations.

The schema that freeRADIUS uses is deliberately designed to behave in a very similar way to the `files` module. The tables `radcheck` and `radreply` correspond almost directly to check items and reply items in the `authorize` file. The `radusergroup` table handles group membership, and `radgroupcheck` / `radgroupreply` provide the group-level equivalents. In most cases, if something works in the `authorize` file, the same logic can be made to work in SQL with very little change to your policies.

Each SQL dialect supported by freeRADIUS (sqlite, mysql, postgresql, mssql, oracle, etc.) has its own subdirectory under:

`mods-config/sql/main/<dialect>/`

Inside you will find:

- `schema.sql` — the schema that create the required tables and indexes
- `queries.conf` — the actual SQL queries that executes during authorisation, accounting, post-auth, etc.

The main configuration file for the module itself lives in `mods-available/sql`. This file contains the connection parameters, pool settings, dialect selection, and — most importantly — an `$INCLUDE` directive that pulls in the correct dialect-specific `queries.conf`.

== Step 1 — Enable and configure the sql module

The most common way to activate the SQL module is:

[source,bash]
----
$ cd raddb/mods-enabled
$ ln -s ../mods-available/sql sql
----

Next, open `mods-available/sql` and configure it for mysql testing. A minimal working configuration looks like this:

[source,unlang]
----
sql {

	dialect = "mysql"

	driver = "${dialect}"

	server = "localhost"
	port = 3306
	login = "radius"
	password = "radpass"
	radius_db = "radius"

	acct_table1 = "radacct"
	acct_table2 = "radacct"

	postauth_table = "radpostauth"
	authcheck_table = "radcheck"
	groupcheck_table = "radgroupcheck"
	authreply_table = "radreply"
	groupreply_table = "radgroupreply"
	usergroup_table = "radusergroup"

	pool {
		start = 0
		min = 1
		max = 100
		connecting = 2
		uses = 0
		lifetime = 0
	}
	group_attribute = "${.:instance}-Group"

	$INCLUDE ${modconfdir}/${.:name}/main/${dialect}/queries.conf
}

----

== Step 2 — Make the virtual server use the sql module

Almost all real deployments use at least one named virtual server. The simplest way to start is to edit the default one.

Open `sites-enabled/default` and locate the `recv Access-Request { … }` section.

A very common and safe pattern is to call the `sql` module early and then check whether it returned useful data:

[source,unlang]
----
server default {
    namespace = radius

    recv Access-Request {
        # If the site already have files, suffix, etc. here — keep them
        sql
    }

    recv Accounting-Request {
        sql
        ok
    }
}
----
you should start the server as usual:

------------
$ radiusd -X
------------

If all has gone well, the server should print out the normal "Ready to
process requests" message. Scroll up in your terminal window, and there
should be messages from the `sql` module, such as:

--------------
rlm_sql_sqlite: Database doesn't exist, creating it and loading schema
rlm_sql_sqlite: Executing SQL statements from file "/etc/raddb/mods-config/sql/main/sqlite/schema.sql"
rlm_sql (sql): Driver rlm_sql_sqlite (module rlm_sql_sqlite) loaded and linked
rlm_sql (sql): Attempting to connect to database "radius"
rlm_sql (sql): Initialising connection pool
   pool {
   	start = 5
   	min = 4
   	max = 100
   	spare = 3
   	uses = 0
   	lifetime = 0
   	cleanup_interval = 30
   	idle_timeout = 60
   	retry_delay = 1
   	spread = no
   }
rlm_sql (sql): Opening additional connection (0)
rlm_sql_sqlite: Opening SQLite database "/tmp/freeradius.db"
rlm_sql (sql): Opening additional connection (1)
rlm_sql_sqlite: Opening SQLite database "/tmp/freeradius.db"
rlm_sql (sql): Opening additional connection (2)
rlm_sql_sqlite: Opening SQLite database "/tmp/freeradius.db"
rlm_sql (sql): Opening additional connection (3)
rlm_sql_sqlite: Opening SQLite database "/tmp/freeradius.db"
rlm_sql (sql): Opening additional connection (4)
rlm_sql_sqlite: Opening SQLite database "/tmp/freeradius.db"
--------------

These messages indicate that the server was able to load the `sql`
module, and that the `sql` module was able to communicate with the SQL
server.

If there is a problem with shared libraries, or with access permissions
to the SQL database, then an error message will be printed, and the
server will not start properly. The FreeRADIUS FAQ and the
`radiusd.conf` file, entry "libdir", contain information as to how to
fix shared library issues.

If there are issues connecting to the database you should verify manually
that you can connect to the SQL database using the given "server",
"login", and "password". The SQL database should come with a test
client which may be used to perform this test.

Now stop the server. The next exercise will be to add the schema to the
database, and to populate it with a test entry.

== Questions

1.  Why is it important to test SQL connectivity, independently of
testing the ability to obtain user configuration from an SQL database?
2.  Why are there different configuration files for each SQL server?
3.  What additional benefits, not mentioned here, do SQL databases have
over the files module?

// Copyright (C) 2021 Network RADIUS SAS.  Licenced under CC-by-NC 4.0.
// This documentation was developed by Network RADIUS SAS.
