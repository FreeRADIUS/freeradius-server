= Communicating with an SQL database

*Goal:* Configure the server so that it can communicate with an SQL database and retrieve user authentication and authorisation information directly from that database instead of (or in addition to) the flat `authorize` file.

*Time:* 25–45 minutes

*Files you will need to look at or edit:*

- `mods-available/sql`
- `mods-config/sql/main/<dialect>/schema.sql`
- `mods-config/sql/main/<dialect>/queries.conf`
- `sites-enabled/default`

Many sites start with user information stored in the classic `authorize` file because it is simple and quick to edit. However, once the number of authorize grows into the thousands — or especially into the tens or hundreds of thousands — maintaining that file becomes impractical. Flat files do not offer fast indexed lookups, concurrent writes from multiple tools become dangerous, and most network management systems or billing platforms cannot easily update a text file safely.

This is where SQL databases become very attractive. Modern relational databases are designed to handle millions of records, provide extremely fast indexed searches, support transactions, allow many different applications to read and write data safely, and come with a huge ecosystem of management tools, backup solutions, replication options, and monitoring integrations.

The schema that freeRADIUS uses is deliberately designed to behave in a very similar way to the `files` module. The tables `radcheck` and `radreply` correspond almost directly to check items and reply items in the `authorize` file. The `radusergroup` table handles group membership, and `radgroupcheck` / `radgroupreply` provide the group-level equivalents. In most cases, if something works in the `authorize` file, the same logic can be made to work in SQL with very little change to your policies.

Each SQL dialect supported by freeRADIUS (sqlite, mysql, postgresql, mssql, oracle, etc.) has its own subdirectory under:

`mods-config/sql/main/<dialect>/`

Inside you will find:

- `schema.sql` — the schema that create the required tables and indexes
- `queries.conf` — the actual SQL queries that executes during authorisation, accounting, post-auth, etc.

The main configuration file for the module itself lives in `mods-available/sql`. This file contains the connection parameters, pool settings, dialect selection, and — most importantly — an `$INCLUDE` directive that pulls in the correct dialect-specific `queries.conf`.

== Step 1 — Enable and configure the sql module

The most common way to activate the SQL module is:

[source,bash]
----
$ cd raddb/mods-enabled
$ ln -s ../mods-available/sql sql
----

Next, open `mods-available/sql` and configure it for mysql testing. A minimal working configuration looks like this:

[source,unlang]
----
sql {

	dialect = "mysql"

	driver = "${dialect}"

	server = "localhost"
	port = 3306
	login = "radius"
	password = "radpass"
	radius_db = "radius"

	acct_table1 = "radacct"
	acct_table2 = "radacct"

	postauth_table = "radpostauth"
	authcheck_table = "radcheck"
	groupcheck_table = "radgroupcheck"
	authreply_table = "radreply"
	groupreply_table = "radgroupreply"
	usergroup_table = "radusergroup"

	pool {
		start = 0
		min = 1
		max = 100
		connecting = 2
		uses = 0
		lifetime = 0
	}
	group_attribute = "${.:instance}-Group"

	$INCLUDE ${modconfdir}/${.:name}/main/${dialect}/queries.conf
}

----

== Step 2 — Make the virtual server use the sql module

Almost all real deployments use at least one named virtual server. The simplest way to start is to edit the default one.

Open `sites-enabled/default` and locate the `recv Access-Request { … }` section.

A very common and safe pattern is to call the `sql` module early and then check whether it returned useful data:

[source,unlang]
----
server default {
    namespace = radius

    recv Access-Request {
        # If the site already have files, suffix, etc. here — keep them
        sql
    }

    recv Accounting-Request {
        sql
        ok
    }
}
----
== Step 3 — Start the server in debug mode to verify startup

Run the server in foreground debug mode so you can watch everything that happens:

[source,bash]
----
$ radiusd -X
----

You should see messages similar to these when everything is working correctly:

[source,text]
----
including configuration file ./scripts/bin/../../raddb/mods-enabled/sql
including configuration file ./scripts/bin/../../raddb/mods-config/sql/driver/mysql
including configuration file ./scripts/bin/../../raddb/mods-config/sql/main/mysql/queries.conf
...
Loaded module rlm_sql
    sql {
      driver = mysql
rlm_sql_mysql - libmysql version: 3.2.6
Loaded module rlm_sql_mysql
      mysql {
        tls {
        }
        warnings = auto
      }
      server = "localhost"
      port = 3306
      login = "radius"
      password = <<< secret >>>
      radius_db = "radius"
      read_groups = yes
      group_attribute = "sql-Group"
      read_profiles = yes
      safe_characters = "@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_: /"
      query_timeout = 5
      pool {
        start = 0
        min = 1
        max = 100
        connecting = 2
        uses = 0
        lifetime = 0
        idle_timeout = 0
        open_delay = 0.2
        close_delay = 10.0
        manage_interval = 0.2
        max_backlog = 1000
        connection {
          connect_timeout = 3.0
          reconnect_delay = 1
        }
        request {
          per_connection_max = 2000
          per_connection_target = 1000
          free_delay = 10.0
        }
      }
    }
...
Bootstrapping rlm_sql "sql"
...
Instantiating rlm_sql "sql"
Instantiating rlm_sql_mysql "sql.mysql"
...
sql - [3] - Signalled to start from HALTED state
sql - [3] - Connection changed state HALTED -> INIT
sql - [3] - Starting connect to MySQL server
sql - [3] - Connecting to database 'radius' on localhost:3306, fd 31
sql - [3] - Connection changed state INIT -> CONNECTING
...
sql - [3] - Connected to database on Localhost via UNIX socket, server version 8.0.44, protocol version 10
sql - [3] - Signalled connected from CONNECTING state
sql - [3] - Connection changed state CONNECTING -> CONNECTED
sql - [3] - Connection established
Ready to process requests
----

== Questions

1.  Why is it important to test SQL connectivity, independently of
testing the ability to obtain user configuration from an SQL database?
2.  Why are there different configuration files for each SQL server?
3.  What additional benefits, not mentioned here, do SQL databases have
over the files module?

// Copyright (C) 2021 Network RADIUS SAS.  Licenced under CC-by-NC 4.0.
// This documentation was developed by Network RADIUS SAS.
