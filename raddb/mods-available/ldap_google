# -*- text -*-
#
#  $Id$

#
#  An instance of the ldap module configured for using the G Suite /
#  Google Workspace Secure LDAP server.
#
#  In order to use the Google LDAP server firstly a client must be
#  created. See Google's documentation for doing this:
#  https://support.google.com/a/answer/9048434?hl=en&ref_topic=9173976
#
#  Standard Google LDAP authenticaiton is done using a client certificate,
#  however, FreeRADIUS does require a username and password in addition.
#  Before downloading the client certificate, choose the option to
#  generate access credentials in order to obtain a username and password.
#
#  Ensure the client which is set up for FreeRADIUS has sufficient
#  permissions to read user information, and, if group membership is
#  part of the FreeRADIUS policy, ensure that the client can read
#  group information.
#
#  Importantly, the Google LDAP does not present user passwords in search
#  results.  Therefore, if Google LDAP is to be used for authentication
#  it has to be done using LDAP bind authentication and therefore the
#  authentication method chosen must provide the user password in plain text.
#
#  The Google Secure LDAP service has been observed to have poor performance
#  compared to a dedicated LDAP services.  Therefore if it is to be used
#  as part of a system which is likely to repeatedly be querying the same
#  information (e.g. 802.1x WiFi where users migrate regularly between
#  access points causing re-authentication), it is strongly advised to
#  use the cache module to reduce LDAP queries.
#
#  Comments in this file are specific to using the Google Secure LDAP
#  service.  For other details see the `ldap` sample module.
#
ldap ldap_google {
	#  The standard Google LDAP server URL
	server = 'ldaps://ldap.google.com:636/'

	#  Google LDAP client username and password as generated during
	#  client creation.
#	identity = 'myuser'
#	password = 'mypass'

	#  Base dn for the organisation.
	base_dn = 'dc=example,dc=org'

	#
	#  The default Google LDAP schema can be seen here
	#  https://support.google.com/a/answer/9188164 and custom
	#  attributes can be added to user profiles which can be accessed
	#  in the LDAP directory https://support.google.com/a/answer/6208725
	#
	#  You can run the 'ldapsearch' command line tool using the
	#  parameters from this module's configuration.
	#
	#    LDAPTLS_REQCERT=ALLOW \
	#    LDAPTLS_CERT="<Google certificate file>" \
	#    LDAPTLS_KEY="<Google key file>" \
	#    ldapsearch -H ${server}  -b '${base_dn}' '(uid=user)'
	#
	#  That will give you the LDAP information for 'user'.
	#
	#  Group membership can be queried by using the above "ldapsearch" string,
	#  and adding "memberof" qualifiers.
	#

#	valuepair_attribute = 'radiusAttribute'

	update {
#		reply:Reply-Message		:= 'radiusReplyMessage'
#		reply:Tunnel-Type		:= 'radiusTunnelType'
#		reply:Tunnel-Medium-Type	:= 'radiusTunnelMediumType'
#		reply:Tunnel-Private-Group-ID	:= 'radiusTunnelPrivategroupId'

		control:			+= 'radiusControlAttribute'
		request:			+= 'radiusRequestAttribute'
		reply:				+= 'radiusReplyAttribute'
	}

	#  In order to use ldap bind authentication, add
	#  following "if" statement to the authorize {} section of
	#  the virtual server, after the "ldap" module.  For example:
	#
	#    ...
	#    ldap_google
	#    if ((ok || updated) && User-Password && !control:Auth-Type) {
	#        update {
	#            &control:Auth-Type := ldap
	#        }
	#    }
	#    ...
	#
	#  You will also need to uncomment the "Auth-Type LDAP" block in the
	#  "authenticate" section.
	#

	user_dn = "LDAP-UserDn"

	#
	#  User object identification.
	#
	user {
		#  Typical Google LDAP hierarchies have users under ou=Users...
		base_dn = "ou=Users,${..base_dn}"

		filter = "(uid=%{%{Stripped-User-Name}:-%{User-Name}})"

		scope = 'sub'

#		sort_by = '-uid'

#		access_attribute = 'dialupAccess'

#		access_positive = yes
	}

	#
	#  User membership checking.
	#
	group {
		#  Typical Google LDAP hierarchies have groups under ou=Groups...
		base_dn = "ou=Groups,${..base_dn}"

		filter = '(objectClass=posixGroup)'

		scope = 'sub'

		name_attribute = cn

		#
		#  Google Secure LDAP supports the "memberOf" attribute
		#  which is more efficient than using this filter.  Check
		#  permissions of the client to ensure that reading of group
		#  data is allowed.
		#
#		membership_filter = "(|(member=%{control:${..user_dn}})(memberUid=%{%{Stripped-User-Name}:-%{User-Name}}))"

		membership_attribute = 'memberOf'

		#
		#  If the "memberOf" attribute is used for retrieving group membership
		#  it is advised that "cacheable_dn" is used for caching the group details.
		#  "memberOf" is a list of fully quallified group DNs which the user belongs to
		#  so using the DN for the cache avoids further lookups to retrieve group names.
		#
#		cacheable_name = 'no'
#		cacheable_dn = 'no'

#		cache_attribute = 'LDAP-Cached-Membership'

#		allow_dangling_group_ref = 'no'
	}

	options {
#		dereference = 'always'

		#  Google Secure LDAP does not appear to do referrals
		chase_referrals = no
#		rebind = yes

		#  Some reasonable defaults for use with Google Secure LDAP
		res_timeout = 10
		srv_timelimit = 3
		net_timeout = 3
		idle = 60
		probes = 3
		interval = 3

		ldap_debug = 0x0000
	}

	tls {

		#
		#  The certificate and key downloaded when configuring
		#  the client should be referenced here
		#
#		certificate_file = /path/to/google/ldap/certificate.crt
#		private_key_file = /path/to/google/ldap/key.key
#		random_file = /dev/urandom

		#
		#  Google Secure LDAP uses a self signed certificate
		#  so this needs to be 'allow'
		#

		require_cert	= 'allow'

#		tls_min_version = "1.2"
	}

	pool {
		start = ${thread[pool].start_servers}

		min = ${thread[pool].min_spare_servers}

		max = ${thread[pool].max_servers}

		spare = ${thread[pool].max_spare_servers}

		uses = 0

		retry_delay = 30

		lifetime = 0

		idle_timeout = 60
	}
}
