#
#  This module decrypts and validates Yubikey static and dynamic
#  OTP tokens.
#
yubikey {
	#
	#  The length (number of ASCII bytes) of the Public-ID portion
	#  of the OTP string.
	#
	#  Yubikey defaults to a 6 byte ID (2 * 6 = 12)
#	id_length = 12

	#
	#  If true, the authorize method of rlm_yubikey will attempt to split the
	#  value of User-Password, into the user's password and the OTP token.
	#
	#  If enabled and successful, the value of User-Password will be truncated
	#  and request:Yubikey-OTP will be added.
	#
#	split = yes

	#
	#  Decrypt mode - Tokens will be decrypted and processed locally
	#
	#  This module should be placed before the persistent storage module for
	#  the authorize section and the yubikey_authorize_otpkey policy should be
	#  placed directly after the persistent storage module.
	#
	#  The authenticate section should have the following added:
	#	 Auth-Type yubikey {
	#	#	pap
	#		yubikey
	#	#	yubikey_authenticate_id
	#	#	yubikey_authenticate_counter
	#	 }
	#  If two factor authentication (password concatenated with OTP) is required,
	#   split should be set to yes and the pap module should be uncommented. Each
	#   account will need a password added (using attribute Cleartext-Password or
	#   preferably SSHA-Password, PBKDF2-Password, etc.).
	#  If the suggested check of the Yubikey-Private-ID for validation is required,
	#   uncomment the yubikey_authenticate_id policy. Each account will need
	#   the Yubikey-Private-ID attribute added.
	#  If the suggested check of the Yubikey-Counter for replay check is required,
	#   uncomment the yubikey_authenticate_counter policy. Each account will need
	#   the Yubikey-Counter attribute added.
	#
	#  The module itself does not provide persistent storage as this
	#  would be duplicative of functionality already in the server.
	#
	#  Yubikey authentication requires the following control attribute retrieved
	#  from persistent storage:
	#    * Yubikey-Key        - (16-byte binary)
	#                           The AES-128 key used to decrypt the OTP data.
	#  If the Yubikey-Key attribute exists in persistent storage for an account,
	#  the mandatory requirement for OTP incorporation in the password may be
	#  checked using the yubikey_authorize_otpkey policy.
	#
	#  These attributes are available after authentication (if successfully decoded):
	#    * Yubikey-Private-ID - (6-byte binary)
	#                           The hidden ID included in OTP data. This may be
	#                           compared with the persistent storage attribute of the
	#                           same name to validate the token by using the
	#                           yubikey_authenticate_id policy.
	#    * Yubikey-Counter    - (16-bit session count & 8-bit use count concatenated
	#                           as a 24-bit monotonically strictly increasing integer
	#                           until the invidual count ceiling is hit)
	#                           This may be compared with the persistent storage
	#                           attribute of the same name to prevent replay attacks
	#                           by using the yubikey_authenticate_counter policy.
	#    * Yubikey-Timestamp  - (24-bit increasing integer @ 8 Hz with rollover which
	#                           is randomly initialized each session)
	#                           This is not currently used in the authenticate
	#                           policies, but may be incorporated for a successive
	#                           relative time estimation between single session OTPs
	#                           (if the session is under 24 days).
	#    * Yubikey-Random     - (16-bit integer)
	#                           Randomly generated value from the token. In the
	#                           current lterature publically available, the
	#                           randomness of the token has not been extensively
	#                           tested to cryptographic standards.
	#                           Use at your discretion.
	#
	#  These attributes are available after authorization:
	#    * Yubikey-Public-ID  - (if OTP found, id_length modhex string)
	#                           The public ID included in the OTP string.
	#  Any password >= 32 + id_length is assumed to incorporate the OTP and will noop
	#  if the OTP is not found to match a modhex string.
	#
	#  The Yubikey-Public-Id and/or User-Name attributes may be used to retrieve
	#  the Yubikey-Key, Yubikey-Private-ID, etc. by modifying the sql module main
	#  queries from
	#	sql_user_name = "%{User-Name}"
	#  to
	#	sql_user_name = "%{Yubikey-Public-ID}"
	#  or
	#	sql_user_name = "%{%{Yubikey-Public-ID}:-%{User-Name}}"
	#  If Yubikey-Public-ID is used, place the yubikey_authorize_username policy
	#   directly after the authorize section persistent storage module and add a
	#   User-Name attribute for each token. This policy may be used to test for
	#   a mismatch of token and user, if the account has the mandatory Yubikey-Key.
	#
	decrypt = no

	#
	#  Validation mode - Tokens will be validated against a Yubicloud server
	#
	validate = no

	#
	#  Settings for validation mode.
	#
	validation {
		#
		#  URL of validation server, multiple URL config items may be used
		#  to list multiple servers.
		#
		# - %d is a placeholder for public ID of the token
		# - %s is a placeholder for the token string itself
		#
		#  If no URLs are listed, will default to the default URLs in the
		#  ykclient library, which point to the yubico validation servers.
		servers {
#			uri = 'http://api.yubico.com/wsapi/2.0/verify?id=%d&otp=%s'
#			uri = 'http://api2.yubico.com/wsapi/2.0/verify?id=%d&otp=%s'
		}

		#
		#  API Client ID
		#
		#  Must be set to your client id for the validation server.
		#
#		client_id = 00000

		#
		#  API Secret key (Base64 encoded)
		#
		#  Must be set to your API key for the validation server.
		#
#		api_key = '000000000000000000000000'

		#
		#  Connection pool parameters
		#
		pool {
			# Number of connections to start
			start = ${thread[pool].start_servers}

			# Minimum number of connections to keep open
			min = ${thread[pool].min_spare_servers}

			# Maximum number of connections
			#
			# If these connections are all in use and a new one
			# is requested, the request will NOT get a connection.
			#
			# NOTE: This should be greater than or equal to "min" above.
			max = ${thread[pool].max_servers}

			# Spare connections to be left idle
			#
			# NOTE: Idle connections WILL be closed if "idle_timeout"
			# is set.  This should be less than or equal to "max" above.
			spare = ${thread[pool].max_spare_servers}

			# Number of uses before the connection is closed
			#
			# NOTE: A setting of 0 means infinite (no limit).
			uses = 0

			# The lifetime (in seconds) of the connection
			#
			# NOTE: A setting of 0 means infinite (no limit).
			lifetime = 0

			# The idle timeout (in seconds).  A connection which is
			# unused for this length of time will be closed.
			#
			# NOTE: A setting of 0 means infinite (no timeout).
			idle_timeout = 60

			# NOTE: All configuration settings are enforced.  If a
			# connection is closed because of "idle_timeout",
			# "uses", or "lifetime", then the total number of
			# connections MAY fall below "min".  When that
			# happens, it will open a new connection.  It will
			# also log a WARNING message.
			#
			# The solution is to either lower the "min" connections,
			# or increase lifetime/idle_timeout.

			# Enable LRU (Least Recently Used)
			#
			# The yubico library uses curl multihandles. If the
			# multihandle is reused before all requests are completed
			# the connections are re-established.
			#
			# The cost of re-establishing the connections is greater
			# than the benefit of maintaining a small pool of
			# connections or optimising for link latency.
			spread = yes
		}
	}
}
