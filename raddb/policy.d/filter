#
#	Example of forbidding all attempts to login via
#	realms.
#
deny_realms {
	if (&User-Name && &User-Name =~ /@/) {
	#if (&User-Name && &User-Name =~ /@|\\/) {
		update reply {
			Module-Failure-Message = 'Rejected: User-Name contains a realm'
		}
		reject
	}
}

#
#	Filter the User-Name
#
#  Force some sanity on User-Name. This helps to avoid issues
#  issues where the back-end database is "forgiving" about
#  what constitutes a user name.
#
filter_username {
	if (&User-Name) {
		#
		#  reject mixed case and upper case e.g. "UseRNaMe", "USERNAME"
		#
		#if (&User-Name != "%{tolower:%{User-Name}}") {
		#	reject
		#}

		#
		#  reject all whitespace
		#  e.g. "user@ site.com", or "us er", or " user", or "user "
		#
		if (&User-Name =~ / /) {
			update reply {
				Module-Failure-Message = 'Rejected: User-Name contains whitespace'
			}
			reject
		}

		#
		#  reject multiple realm delimiters
		#  e.g. "user@site.com@site.com"
		#  e.g. "site.com\site.com\user"
		#
		if (&User-Name =~ /[@][^@]*[@]/ ) {
		#if (&User-Name =~ /[@\\][^@\\]*[@\\]/ ) {
			update reply {
				Module-Failure-Message = 'Rejected: Multiple realm delimiters in User-Name'
			}
			reject
		}

		#
		#  reject multiple dots in the realm
		#  e.g. "user@site..com"
		#  e.g. "site..com\user"
		#
		if (&User-Name =~ /@[^.]*\.\./ ) {
		#if (&User-Name =~ /@[^.]*\.\.|\.\.[^.]*\\/ ) {
			update reply {
				Module-Failure-Message = 'Rejected: Realm contains ..s'
			}
			reject
		}

		#
		#  reject where there is not at least 1 string-dot-string in the realm
		#  e.g. "user@site"
		#  e.g. "site\user"
		#
		if (&User-Name =~ /@/ && &User-Name !~ /@[^.]+\.[^.]+/)  {
		#if (&User-Name =~ /@|\\/ && &User-Name !~ /@[^.]+\.[^.]+|[^.]+\.[^.]+\\/)  {
			update reply {
				Module-Failure-Message = 'Rejected: Realm does not have at least one dot separator'
			}
			reject
		}

		#
		#  reject realms that end with a dot
		#  e.g. "user@site.com."
		#  e.g. "site.com.\user"
		#
		if (&User-Name =~ /@.*\.$/) {
		#if (&User-Name =~ /@.*\.$|.*\.\\/) {
			update reply {
				Module-Failure-Message = 'Rejected: Realm ends with a dot'
			}
			reject
		}

		#
		#  reject realms that begin with a dot
		#  e.g. "user@.site.com"
		#  e.g. ".site.com\user"
		#
		if (&User-Name =~ /@\..*$/)  {
		#if (&User-Name =~ /@\..*$|\..*\\/)  {
			update reply {
				Module-Failure-Message = 'Rejected: Realm begins with a dot'
			}
			reject
		}
	}
}

#
#	Filter the User-Password
#
#  Some equipment sends passwords with embedded zeroes.
#  This policy filters them out.
#
filter_password {
	if (&User-Password && &User-Password != "%{string:User-Password}") {
		update request {
			&Tmp-String-0 := "%{string:User-Password}"
			&User-Password := "%{string:Tmp-String-0}"
		}
	 }
}

#
#	Filter the inner and outer identities
#
#  Do checks on outer and inner identities so that users
#  cannot spoof us by using incompatible identities
#
filter_inner_outer_identity {
	#
	#  No inner or outer User-Name? Reject.
	#
	if (!&outer.request:User-Name || !&User-Name) {
		update request {
			Module-Failure-Message = 'Rejected: Inner and outer identities are required for tunnelled authentication'
		}
		reject
	}

	#
	#  Do lots of sanity checks.
	#
	#  Get the outer stripped user name. Look for the outer realm.
	#
	if (&outer.request:User-Name =~ /^([^@]+)?(@([^@]+)?)?$/) {
	#if (&outer.request:User-Name =~ /^([^@\\]+)?(@([^@\\]+)?)?$/) {
		update request {
			Outer-Stripped-User-Name = "%{1}"
			Outer-Realm-Name = "%{3}"
		}
	}
	#elsif (&outer.request:User-Name =~ /^(([^@\\]+)?\\)?([^@\\]+)?$/) {
	#	update request {
	#		Outer-Stripped-User-Name = "%{3}"
	#		Outer-Realm-Name = "%{1}"
	#	}
	#}
	else {
		reject
	}

	#
	#  Get the inner stripped user name. Look for the inner realm.
	#
	if (&User-Name =~ /^([^@]+)?(@([^@]+)?)?$/) {
	#if (&User-Name =~ /^([^@\\]+)?(@([^@\\]+)?)?$/) {
		update request {
			Inner-Stripped-User-Name = "%{1}"
			Inner-Realm-Name = "%{3}"
		}
	}
	#elsif (&User-Name =~ /^(([^@\\]+)?\\)?([^@\\]+)?$/) {
	#	update request {
	#		Inner-Stripped-User-Name = "%{3}"
	#		Inner-Realm-Name = "%{1}"
	#	}
	#}
	else {
		reject
	}

	#
	#  We require that the inner User-Name not
	#  be "anonymous", "anon", "@realm",
	#  "anonymous@realm" or "anon@realm".
	#
	#  The check for "anonymous" is more relaxed,
	#  disallowing "anon" because some vendors
	#  send this in the outer instead of
	#  following the standards.
	#
	if (&Inner-Stripped-User-Name =~ /^(anon(ymous)?)?$/) {
		update request {
			Module-Failure-Message = "Rejected: Inner identity, '%{User-Name}', cannot be anonymized. Expected something other than 'anonymous', 'anon' or empty string"
		}
		reject
	}

	if (&Outer-Stripped-User-Name == &Inner-Stripped-User-Name) {
		#  The stripped inner and outer User-Name are the same.
		#  Ensure that the inner and outer realms are the same where they are both defined.
		if (&Outer-Realm-Name != "" && \
			&Inner-Realm-Name != "" && \
			&Inner-Realm-Name != &Outer-Realm-Name) {
			update request {
				Module-Failure-Message = "Rejected: Realm in the inner identity, '%{User-Name}', is not the same as the realm in the outer identity, '%{outer.request:User-Name}'. Expected '%{Outer-Stripped-User-Name}' or '%{Inner-Stripped-User-Name}' in both cases because the outer identity is not anonymized"
			}
			reject
		}
	}
	else {
		#
		#  The stripped inner and outer User-Name are different.
		#  Perform anonimization checks.
		#
		#  We require that the outer User-Name be
		#  "anonymous", "anon", "@realm",
		#  "anonymous@realm" or "anon@realm".
		#
		#  The check for "anonymous" is more relaxed,
		#  allowing "anon" because some vendors send
		#  this instead of following the standards.
		#
		if ((&Outer-Realm-Name == "" && \
			&Outer-Stripped-User-Name !~ /^anon(ymous)?$/) || \
			&Outer-Stripped-User-Name !~ /^(anon(ymous)?)?$/) {
			update request {
				Module-Failure-Message = "Rejected: Outer identity, '%{outer.request:User-Name}', is not anonymized correctly. Expected an empty string or 'anonymous' instead of '%{Outer-Stripped-User-Name}'"
			}
			reject
		}

		#
		#  It is OK to have outer realm "@example.com" and
		#  inner User-Name "bob".  We do more detailed checks
		#  only if an inner and outer realm exists.
		#
		#  It is OK to have the same realm name, or
		#  the outer one is "example.com" and the inner
		#  is e.g. "secure.example.com"
		#
		#  Note that we do EQUALITY checks for realm names.
		#  There is no simple way to do case insensitive checks
		#  on internationalized domain names.  On top of that,
		#  allowing outer "anonymous@EXAMPLE.COM" and inner
		#  "user@example.com" is just stupid.  The user should
		#  enter the same realm for both inner and outer identities.
		#
		if (&Outer-Realm-Name != "" && \
			&Inner-Realm-Name != "" && \
			&Inner-Realm-Name !~ /(\.)?%{Outer-Realm-Name}$/) {
			update request {
				Module-Failure-Message = "Rejected: Realm in the inner identity, '%{User-Name}', is not the same as or a subrealm of the realm in the anonymized outer identity, '%{outer.request:User-Name}'. Expected '%{Inner-Realm-Name}' or 'subdomain.%{Inner-Realm-Name}'"
			}
			reject
		}

		#
		#  It's OK to have an outer realm and no inner realm.
		#

		#
		#  It's OK to have an inner realm and no outer realm.
		#
	}
}
