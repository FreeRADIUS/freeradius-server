#
#	Example of forbidding all attempts to login via
#	realms.
#
deny_realms {
	#
	#  reject realms
	#  e.g. "user@example.com"
	#  e.g. "example.com\user" (disabled by default)
	#
	if (&User-Name && &User-Name =~ /@/) {
	#if (&User-Name && &User-Name =~ /@|\\/) {
		update request {
			&Module-Failure-Message += 'User-Name contains a realm'
		}
		reject
	}
}

#
#	Filter the User-Name
#
#  Force some sanity on User-Name. This helps to avoid issues
#  issues where the back-end database is "forgiving" about
#  what constitutes a user name.
#
filter_username {
	if (&User-Name) {
		#
		#  reject mixed case and upper case e.g. "uSeR@EXamplE.com", "USER@EXAMPLE.COM"
		#
		#if (&User-Name != "%{tolower:%{User-Name}}") {
		#	reject
		#}

		#
		#  reject all whitespace
		#  e.g. "user@ example.com", or "us er", or " user", or "user "
		#
		if (&User-Name =~ / /) {
			update request {
				&Module-Failure-Message += 'User-Name contains whitespace'
			}
			reject
		}

		#
		#  reject multiple realm delimiters
		#  e.g. "user@example.com@example.com"
		#  e.g. "example.com\example.com\user" (disabled by default)
		#
		if (&User-Name =~ /@[^@]*@/ ) {
		#if (&User-Name =~ /[@\\][^@\\]*[@\\]/ ) {
			update request {
				&Module-Failure-Message += 'Multiple realm delimiters in User-Name'
			}
			reject
		}

		#
		#  reject multiple dots in the realm
		#  e.g. "user@example..com"
		#  e.g. "example..com\user" (disabled by default)
		#
		if (&User-Name =~ /@[^.]*\.\./ ) {
		#if (&User-Name =~ /@[^.]*\.\.|\.\.[^.]*\\/ ) {
			update request {
				&Module-Failure-Message += 'Realm contains multiple ..s'
			}
			reject
		}

		#
		#  reject where there is not at least 1 string-dot-string in the realm
		#  e.g. "user@example"
		#  e.g. "example\user" (disabled by default)
		#
		if (&User-Name =~ /@/ && &User-Name !~ /@[^.]+\.[^.]+/)  {
		#if (&User-Name =~ /@|\\/ && &User-Name !~ /@[^.]+\.[^.]+|[^.]+\.[^.]+\\/)  {
			update request {
				&Module-Failure-Message += 'Realm does not have at least one dot separator'
			}
			reject
		}

		#
		#  reject realms that end with a dot
		#  e.g. "user@example.com."
		#  e.g. "example.com.\user" (disabled by default)
		#
		if (&User-Name =~ /@.*\.$/) {
		#if (&User-Name =~ /@.*\.$|.*\.\\/) {
			update request {
				&Module-Failure-Message += 'Realm ends with a dot'
			}
			reject
		}

		#
		#  reject realms that begin with a dot
		#  e.g. "user@.example.com"
		#  e.g. ".example.com\user" (disabled by default)
		#
		if (&User-Name =~ /@\..*$/)  {
		#if (&User-Name =~ /@\..*$|\..*\\/)  {
			update request {
				&Module-Failure-Message += 'Realm begins with a dot'
			}
			reject
		}
	}
}

#
#	Filter the User-Password
#
#  Some equipment sends passwords with embedded zeroes.
#  This policy filters them out.
#
filter_password {
	if (&User-Password && &User-Password != "%{string:User-Password}") {
		update request {
			&Tmp-String-0 := "%{string:User-Password}"
			&User-Password := "%{string:Tmp-String-0}"
		}
	 }
}

#
#	Filter the inner and outer identities
#
#  Do checks on outer and inner identities so that users
#  cannot spoof us by using incompatible identities
#
filter_inner_outer_identity {
	#
	#  No inner or outer identities ? Reject.
	#
	if (!&outer.request:User-Name || !&User-Name) {
		update request {
			&Module-Failure-Message += 'Inner and outer identities are required for tunnelled authentication'
		}
		reject
	}

	#
	#  Do lots of sanity checks.
	#
	#  Get the outer stripped user name. Look for the outer realm.
	#
	if (&outer.request:User-Name =~ /^([^@]+)?(@([^@]+)?)?$/) {
	#if (&outer.request:User-Name =~ /^([^@\\]+)?(@([^@\\]+)?)?$/) {
		update request {
			Outer-Stripped-User-Name = "%{1}"
		}

		if ("%{3}" != "") {
			update request {
				Outer-Realm-Name = "%{3}"
			}
		}
	}
	#elsif (&outer.request:User-Name =~ /^(([^@\\]+)?\\)?([^@\\]+)?$/) {
	#	update request {
	#		Outer-Stripped-User-Name = "%{3}"
	#	}
	#
	#	if ("%{1}" != "") {
	#		update request {
	#			Outer-Realm-Name = "%{1}"
	#		}
	#	}
	#}
	else {
		reject
	}

	#
	#  Get the inner stripped user name. Look for the inner realm.
	#
	if (&User-Name =~ /^([^@]+)?(@([^@]+)?)?$/) {
	#if (&User-Name =~ /^([^@\\]+)?(@([^@\\]+)?)?$/) {
		update request {
			Inner-Stripped-User-Name = "%{1}"
		}

		if ("%{3}" != "") {
			update request {
				Inner-Realm-Name = "%{3}"
			}
		}
	}
	#elsif (&User-Name =~ /^(([^@\\]+)?\\)?([^@\\]+)?$/) {
	#	update request {
	#		Inner-Stripped-User-Name = "%{3}"
	#	}
	#
	#	if ("%{1}" != "") {
	#		update request {
	#			Inner-Realm-Name = "%{1}"
	#		}
	#	}
	#}
	else {
		reject
	}

	#
	#  By default, we require that the inner User-Name not
	#  be "anonymous", "anon", "@realm", "anonymous@realm",
	#  "anon@realm" or empty string.
	#
	#  For a more relaxed definition of anonymous, requiring
	#  that the inner User-Name not start with anon or be an
	#  empty string, use the alternative if statement.
	#
	if (&Inner-Stripped-User-Name =~ /^(anon(ymous)?)?$/) {
	#if (&Inner-Stripped-User-Name =~ /^$|^anon/) {
		update request {
			&Module-Failure-Message += "Inner identity \"%{User-Name}\" cannot be anonymized. Expected something other than \"anonymous\", \"anon\" or empty string"
		}
		reject
	}

	if (&Outer-Stripped-User-Name == &Inner-Stripped-User-Name) {
		#  The stripped inner and outer User-Name are the same.
		#  Ensure that the inner and outer realms are the same where they are both defined.
		if (&Inner-Realm-Name && &Outer-Realm-Name && \
			&Inner-Realm-Name != &Outer-Realm-Name) {
			update request {
				&Module-Failure-Message += "Inner realm \"%{Inner-Realm-Name}\" is not the same as the outer realm, \"%{Outer-Realm-Name}\". Expected \"%{Inner-Realm-Name}\" or \"%{Outer-Realm-Name}\" in both cases."
			}
			reject
		}
	}
	else {
		#
		#  The stripped inner and outer User-Name are different.
		#  Perform anonymization checks.
		#
		#  By default, we require that the outer User-Name be
		#  "anonymous", "anon", "@realm",
		#  "anonymous@realm" or "anon@realm".
		#
		#  The check for "anonymous" is relaxed, also
		#  allowing "anon", because some vendors send
		#  this instead of following the standards.
		#
		#  For a more relaxed check that just requires that
		#  the outer User-Name start with anon, use the
		#  alternative if statement instead.
		#
		if (&Outer-Realm-Name && &Outer-Stripped-User-Name !~ /^(anon(ymous)?)?$/) {
		#if (&Outer-Realm-Name && &Outer-Stripped-User-Name !~ /^$|^anon/) {
			update request {
				&Module-Failure-Message += "Outer identity \"%{outer.request:User-Name}\" is not anonymized correctly. Expected an empty string or \"anonymous\" instead of \"%{Outer-Stripped-User-Name}\""
			}
			reject
		}
		elsif (!&Outer-Realm-Name && \
			&Outer-Stripped-User-Name !~ /^anon(ymous)?$/) {
			#&Outer-Stripped-User-Name !~ /^anon/) {
			update request {
				&Module-Failure-Message += "Outer identity \"%{outer.request:User-Name}\" is not anonymized correctly. Expected \"anonymous\" instead of \"%{Outer-Stripped-User-Name}\""
			}
			reject
		}

		#
		#  It is OK to have outer realm "@example.com" and
		#  inner User-Name "bob".  We do more detailed checks
		#  only if an inner and outer realm exists.
		#
		#  It is OK to have the same realm name, or
		#  the outer one is "example.com" and the inner
		#  is e.g. "secure.example.com"
		#
		#  Note that we do EQUALITY checks for realm names.
		#  There is no simple way to do case insensitive checks
		#  on internationalized domain names.  On top of that,
		#  allowing outer "anonymous@EXAMPLE.COM" and inner
		#  "user@example.com" is just stupid.  The user should
		#  enter the same realm for both inner and outer identities.
		#
		if (&Inner-Realm-Name && &Outer-Realm-Name && \
			&Inner-Realm-Name != &Outer-Realm-Name && \
			&Inner-Realm-Name !~ /\.%{Outer-Realm-Name}$/) {
			update request {
				&Module-Failure-Message += "Inner realm \"%{Inner-Realm-Name}\" is not the same as or a subrealm of the outer realm \"%{Outer-Realm-Name}\". Expected \"%{Inner-Realm-Name}\" or e.g. \"secure.%{Inner-Realm-Name}\""
			}
			reject
		}

		#
		#  It's OK to have an outer realm and no inner realm.
		#  It's OK to have an inner realm and no outer realm.
		#
	}
}
