#
#	Example of forbidding all attempts to login via
#	realms.
#
deny_realms {
	#
	#  No User-Name, skip.
	#
	if (!&User-Name || &User-Name == "") {
		noop
	}

	if (&User-Name =~ /@|\\/) {
		update reply {
			&Reply-Message += 'Rejected: User-Name contains a realm'
		}
		reject
	}
}

#
#	Filter the User-Name
#
#  Force some sanity on User-Name. This helps to avoid issues
#  issues where the back-end database is "forgiving" about
#  what constitutes a user name.
#
filter_username {
	#
	#  No User-Name, skip.
	#
	if (!&User-Name || &User-Name == "") {
		noop
	}

	#
	#  reject mixed case e.g. "UseRNaMe"
	#
	#if (&User-Name != "%{tolower:%{User-Name}}") {
	#	reject
	#}

	#
	#  reject all whitespace
	#  e.g. "user@ site.com", or "us er", or " user", or "user "
	#
	if (&User-Name =~ / /) {
		update reply {
			&Reply-Message += 'Rejected: User-Name contains whitespace'
		}
		reject
	}

	#
	#  reject multiple realm delimiters
	#  e.g. "user@site.com@site.com"
	#  e.g. "site.com\site.com\user"
	#
	if (&User-Name =~ /[@\\][^@\\]*[@\\]/ ) {
		update reply {
			&Reply-Message += 'Rejected: Multiple realm delimiters in User-Name'
		}
		reject
	}

	#
	#  reject multiple dots in the realm
	#  e.g. "user@site..com"
	#  e.g. "site..com\user"
	#
	if (&User-Name =~ /@[^.]*\.\.|\.\.[^.]*\\/ ) {
		update reply {
			&Reply-Message += 'Rejected: Realm contains ..s'
		}
		reject
	}

	#
	#  reject where there is not at least 1 string-dot-string in the realm
	#  e.g. "user@site"
	#  e.g. "site\user"
	#
	if (&User-Name =~ /@|\\/ && &User-Name !~ /@[^.]+\.[^.]+|[^.]+\.[^.]+\\/)  {
		update reply {
			&Reply-Message += 'Rejected: Realm does not have at least one dot separator'
		}
		reject
	}

	#
	#  reject realms that end with a dot
	#  e.g. "user@site.com."
	#  e.g. "site.com.\user"
	#
	if (&User-Name =~ /@.*\.$|.*\.\\/)  {
		update reply {
			&Reply-Message += 'Rejected: Realm ends with a dot'
		}
		reject
	}

	#
	#  reject realms that begin with a dot
	#  e.g. "user@.site.com"
	#  e.g. ".site.com\user"
	#
	if (&User-Name =~ /@\..*$|\..*\\/)  {
		update reply {
			&Reply-Message += 'Rejected: Realm begins with a dot'
		}
		reject
	}
}

#
#	Filter the User-Password
#
#  Some equipment sends passwords with embedded zeroes.
#  This policy filters them out.
#
filter_password {
	#
	#  No user password, skip.
	#
	if (!&User-Password) {
		noop
	}
	
	if (&User-Password != "%{string:User-Password}") {
		update request {
			&Tmp-String-0 := "%{string:User-Password}"
			&User-Password := "%{string:Tmp-String-0}"
		}
	 }
}

#
#	Filter the inner and outer identities
#
#  Do checks on outer and inner identities so that users
#  cannot spoof us by using incompatible identities
#
filter_inner_outer_identity {
	#
	#  No inner or outer User-Name? Reject.
	#
	if (!&outer.request:User-Name || &outer.request:User-Name == "" || !&User-Name || &User-Name == "") {
		update request {
			Module-Failure-Message = 'Rejected: Inner and outer identities are required for tunnelled authentication'
		}
		reject
	}

	#
	#  Do lots of sanity checks.
	#
	#  Get the outer stripped user name. Look for the outer realm.
	#
	if (&outer.request:User-Name =~ /^([^@\\]+)?(@([^@\\]+)?)?$/) {
		#  Case insensitive.
		update request {
			Outer-Stripped-User-Name = "%{tolower:%{1}}"
			Outer-Realm-Name = "%{tolower:%{3}}"
		}
		
		#  Case sensitive.
		#update request {
		#	Outer-Stripped-User-Name = "%{1}"
		#	Outer-Realm-Name = "%{3}"
		#}
	}
	elsif (&outer.request:User-Name =~ /^(([^@\\]+)?\\)?([^@\\]+)?$/) {
		#  Case insensitive.
		update request {
			Outer-Stripped-User-Name = "%{tolower:%{3}}"	
			Outer-Realm-Name = "%{tolower:%{1}}"
		}
		
		#  Case sensitive.
		#update request {
		#	Outer-Stripped-User-Name = "%{3}"
		#	Outer-Realm-Name = "%{1}"
		#}
	}

	#
	#  Get the inner stripped user name. Look for the inner realm.
	#
	if (&User-Name =~ /^([^@\\]+)?(@([^@\\]+)?)?$/) {
		#  Case insensitive.
		update request {
			Inner-Stripped-User-Name = "%{tolower:%{1}}"
			Inner-Realm-Name = "%{tolower:%{3}}"
		}
		
		#  Case sensitive.
		#update request {
		#	Inner-Stripped-User-Name = "%{1}"
		#	Inner-Realm-Name = "%{3}"
		#}
	}
	elsif (&User-Name =~ /^(([^@\\]+)?\\)?([^@\\]+)?$/) {
		#  Case insensitive.
		update request {
			Inner-Stripped-User-Name = "%{tolower:%{3}}"	
			Inner-Realm-Name = "%{tolower:%{1}}"
		}
		
		#  Case sensitive.
		#update request {
		#	Inner-Stripped-User-Name = "%{3}"
		#	Inner-Realm-Name = "%{1}"
		#}
	}

	#
	#  We require that the inner User-Name not be
	#  "@realm", "\realm", "anonymous", "anon"
	#  "anonymous@realm", "realm\anonymous",
	#  "anon@realm" or "realm\anon".
	#
	#  The check for "anonymous" is more relaxed,
	#  disallowing "anon" because some vendors
	#  send this in the outer instead of
	#  following the standards.
	#
	if ((&Inner-Realm-Name == "" && \
		&Inner-Stripped-User-Name =~ /^anon(ymous)?$/) || \
		&Inner-Stripped-User-Name =~ /^(anon(ymous)?)?$/) {
		update request {
			Module-Failure-Message = 'Rejected: Inner identity cannot be anonymized'
		}
		reject
	}

	if (&Outer-Stripped-User-Name == &Inner-Stripped-User-Name) {
		#  The stripped inner and outer User-Name are the same.
		#  Ensure that the inner and outer realms are the same where they are both defined.
		if (&Outer-Realm-Name != "" && \
			&Inner-Realm-Name != "" && \
			&Inner-Realm-Name != &Outer-Realm-Name) {
			update request {
				Module-Failure-Message = 'Rejected: Realm in the inner identity is not the same as the realm in the outer identity'
			}
			reject
		}
	}
	else {
		#
		#  The stripped inner and outer User-Name are different.
		#  Perform anonimization checks.
		#
		#  We require that the outer User-Name be
		#  "@realm", "\realm", "anonymous", "anon"
		#  "anonymous@realm", "realm\anonymous",
		#  "anon@realm" or "realm\anon".
		#
		#  The check for "anonymous" is more relaxed,
		#  allowing "anon" because some vendors send
		#  this instead of following the standards.
		#
		if ((&Outer-Realm-Name == "" && \
			&Outer-Stripped-User-Name !~ /^anon(ymous)?$/) || \
			&Outer-Stripped-User-Name !~ /^(anon(ymous)?)?$/) {
			update request {
				Module-Failure-Message = 'Rejected: Outer identity is not anonymized correctly'
			}
			reject
		}

		#
		#  It is OK to have outer realm "@example.com" and
		#  inner User-Name "bob".  We do more detailed checks
		#  only if an inner and outer realm exists.
		#
		#  It is OK to have the same realm name, or
		#  the outer one is "example.com" and the inner
		#  is "secure.example.com"
		#
		if (&Outer-Realm-Name != "" && \
			&Inner-Realm-Name != "" && \
			&Inner-Realm-Name !~ /(\.)?%{Outer-Realm-Name}$/) {
			update request {
				Module-Failure-Message = 'Rejected: Realm in the inner identity is not the same as or a subrealm of the realm in the anonymized outer identity'
			}
			reject
		}
	}
}
