#
#	Response caching to handle proxy failovers
#
Xeap.authorize {
	cache_eap
	if (ok) {
		#
		#	Expire previous cache entry
		#
		if (&control:State) {
			update control {
				&Cache-TTL := 0
			}
			cache_eap

			update control {
				&State !* ANY
			}
		}

		handled
	}
	else {
		eap.authorize
	}
}

#
#	Populate cache with responses from the EAP module
#
Xeap.authenticate {
	eap {
		handled = 1
	}
	if (handled) {
		cache_eap.authorize

		handled
	}

	cache_eap.authorize
}

#
#       Forbid all EAP types.  Enable this by putting "forbid_eap"
#       into the "authorize" section.
#
forbid_eap {
	if (&EAP-Message) {
		reject
	}
}

#
#       Forbid all non-EAP types outside of an EAP tunnel.
#
permit_only_eap {
	if (!&EAP-Message) {
		#  We MAY be inside of a TTLS tunnel.
		#  PEAP and EAP-FAST require EAP inside of
		#  the tunnel, so this check is OK.
		#  If so, then there MUST be an outer EAP message.
		if (!&outer.request || !&outer.request:EAP-Message) {
			reject
		}
	}
}

#
#       Remove Reply-Message from response if were doing EAP
#
#  Be RFC 3579 2.6.5 compliant - EAP-Message and Reply-Message should
#  not be present in the same response.
#
remove_reply_message_if_eap {
	if (&reply:EAP-Message && &reply:Reply-Message) {
		update reply {
			&Reply-Message !* ANY
		}
	}
	else {
		noop
	}
}


#	Override Framed-MTU value based on mtu settings for NAS

#	Framed-MTU specifies desired length of EAP payload to send.
#	For some NAS this could lead to IP packet fragmentation which can
#	be undesirable. If so, enable this policy in authorize section just
#	before eap call and set nas attribute for a NAS you need to avoid
#	IP fragmentation for.
#	Framed-MTU will be set to a value that eliminates IP fragmentation
#	if Framed-MTU from NAS is too big.

apply_client_mtu_as_framed_mtu {
#	We'll set return status to updated when Framed-MTU is altered
	noop
#	We use &control:Framed-MTU as temporary storage MTU while calculating
#	This attribute is deleted from control once it is not needed
	if (&EAP-Message && "%{client:mtu}") {
#	Offset includes:
#	    - IPv4/IPv6 header, 20/40 bytes
#	    - UDP header, 8 bytes
#	    - RADIUS:
#		* RADIUS header, 4 bytes
#		* Authenticator, 16 bytes
#		* Message-Authenticator, 2 + 16 bytes
#		* State, 2 + 16 bytes
#		* Header for each EAP-Message chunk, 2 bytes
#		* EAP header, 4 bytes + upto 6 bytes for:
#		    o EAP-TLS header (type + flags + tls message length), 6 bytes
#		    o EAP-PWD header, 4 bytes

		if ("%{client:ipv6addr}") {
			update control {
				Framed-MTU := "%{expr:%{client:mtu} - 114 - 2*(1+((%{client:mtu} - 114)/253))}"
			}
		} else {
			update control {
				Framed-MTU := "%{expr:%{client:mtu} - 94 - 2*(1+((%{client:mtu} - 94)/253))}"
			}
		}
		if (!(&request:Framed-MTU) || &control:Framed-MTU < &request:Framed-MTU) {
			update request {
				Framed-MTU := &control:Framed-MTU
			}
			updated
		}
		update control {
			Framed-MTU !* ANY
		}
	}
}
