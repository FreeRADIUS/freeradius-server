#  -*- text -*-
#
#  main/oracle/queries.conf -- Oracle configuration for default schema (schema.sql)
#
#  $Id$

#######################################################################
#  Query config:  Username
#######################################################################
# This is the username that will get substituted, escaped, and added
# as attribute 'SQL-User-Name'.  '%{SQL-User-Name}' should be used below
# everywhere a username substitution is needed so you you can be sure
# the username passed from the client is escaped properly.
#
#  Uncomment the next line, if you want the sql_user_name to mean:
#
#    Use Stripped-User-Name, if it's there.
#    Else use User-Name, if it's there,
#    Else use hard-coded string "DEFAULT" as the user name.
#sql_user_name = "%{Stripped-User-Name || User-Name || 'DEFAULT'}"
#
sql_user_name = "%{User-Name}"

#######################################################################
#  Query config:  Event-Timestamp
#######################################################################
# event_timestamp_epoch is the basis for the time inserted into
# accounting records. Typically this will be the Event-Timestamp of the
# accounting request, which is provided by a NAS.
#
# Uncomment the next line, if you want the timestamp to be based on the
# request reception time recorded by this server, for example if you
# distrust the provided Event-Timestamp.
#event_timestamp_epoch = "%l"

event_timestamp_epoch = %{((integer) Event-Timestamp) || %l}

# event_timestamp is the SQL snippet for converting an epoch timestamp
# to an SQL date.

event_timestamp = "TO_DATE('1970-01-01','YYYY-MM-DD') + NUMTODSINTERVAL(${event_timestamp_epoch},'SECOND')"

#######################################################################
#  Authorization Queries
#######################################################################
#  These queries compare the check items for the user
#  in ${authcheck_table} and setup the reply items in
#  ${authreply_table}.  You can use any query/tables
#  you want, but the return data for each row MUST
#  be in the  following order:
#
#  0. Row ID (currently unused)
#  1. UserName/GroupName
#  2. Item Attr Name
#  3. Item Attr Value
#  4. Item Attr Operation
#######################################################################
#
# WARNING: Oracle is case sensitive
#
# The main difference between MySQL and Oracle queries is the date format.
# You must use the TO_DATE function to transform the radius date format to
# the Oracle date format, and put NULL otherwise '0' in a void date field.
#
#######################################################################

authorize_check_query = "\
	SELECT id, username, attribute, value, op \
	FROM ${authcheck_table} \
	WHERE username = '%{SQL-User-Name}' \
	ORDER BY id"

authorize_reply_query = "\
	SELECT id, username, attribute, value, op \
	FROM ${authreply_table} \
	WHERE username = '%{SQL-User-Name}' \
	ORDER BY id"

authorize_group_check_query = "\
	SELECT id, groupname, attribute, value, op \
	FROM ${groupcheck_table} \
	WHERE groupname = '%{${group_attribute}}' \
	ORDER BY id"

authorize_group_reply_query = "\
	SELECT id, groupname, attribute, value, op \
	FROM ${groupreply_table} \
	WHERE groupname = '%{${group_attribute}}' \
	ORDER BY id"

#######################################################################
# Group Membership Queries
#######################################################################
# group_membership_query	- Check user group membership
#######################################################################

group_membership_query = "\
	SELECT groupname \
	FROM ${usergroup_table} \
	WHERE username='%{SQL-User-Name}' \
	ORDER BY priority"

#######################################################################
# Accounting and Post-Auth Queries
#######################################################################
# These queries insert/update accounting and authentication records.
# The query to use is determined by the name of the section the module
# is called from.
#
# e.g. when called from `accouting Start`, the contents of
#
# accounting {
#	start {}
# }
#
# will be read, and any "query" entries will be run in sequence
# until one returns a positive number of modified rows.
#######################################################################
accounting {
	# Write SQL queries to a logfile. This is potentially useful for bulk inserts
	# when used with the rlm_sql_null driver.
#	logfile = ${logdir}/accounting.sql

	column_list = "\
		acctsessionid,		acctuniqueid,		username, \
		realm,			nasipaddress,		nasportid, \
		nasporttype,		acctstarttime,		acctupdatetime, \
		acctstoptime,		acctsessiontime,	acctauthentic, \
		connectinfo_start,	connectinfo_stop,	acctinputoctets, \
		acctoutputoctets,	calledstationid,	callingstationid, \
		acctterminatecause,	servicetype,		framedprotocol, \
		framedipaddress,	framedipv6address,	framedipv6prefix, \
		framedinterfaceid,	delegatedipv6prefix,	Class"

	accounting-on {
		query = "\
			UPDATE ${...acct_table1} \
			SET \
				acctstoptime = ${...event_timestamp}, \
				acctsessiontime = ROUND((${...event_timestamp} - \
					TO_DATE(TO_CHAR(acctstarttime, 'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss'))*86400), \
				acctterminatecause='%{Acct-Terminate-Cause || 'NAS-Reboot'}' \
			WHERE acctstoptime IS NULL \
			AND nasipaddress = '%{NAS-IP-Address}' \
			AND acctstarttime <= ${...event_timestamp}"

		#
		#  If there are no open user sessions, then the previous query
		#  will return "no rows updated".  The server will then fall through
		#  to the next query, which is just "yes, that's fine".
		#
		query = "SELECT 1 from dual"
	}

	accounting-off {
		query = "${..accounting-on.query}"

		query = "SELECT 1 from dual"
	}

	start {
		query = "\
			INSERT INTO ${...acct_table1} \
				(${..column_list}) \
			VALUES(\
				'%{Acct-Session-Id}', \
				'%{Acct-Unique-Session-Id}', \
				'%{SQL-User-Name}', \
				'%{Realm}', \
				'%{NAS-IP-Address}', \
				'%{NAS-Port-ID || NAS-Port}', \
				'%{NAS-Port-Type}', \
				${...event_timestamp}, \
				${...event_timestamp}, \
				NULL, \
				'0', \
				'%{Acct-Authentic}', \
				'%{Connect-Info}', \
				'', \
				'0', \
				'0', \
				'%{Called-Station-Id}', \
				'%{Calling-Station-Id}', \
				'', \
				'%{Service-Type}', \
				'%{Framed-Protocol}', \
				'%{Framed-IP-Address}', \
				'%{Framed-IPv6-Address}', \
				'%{Framed-IPv6-Prefix}', \
				'%{Framed-Interface-Id}', \
				'%{Delegated-IPv6-Prefix}', \
				'%{Class}')"

		query = "\
			UPDATE ${...acct_table1} \
			SET \
				acctstarttime = ${...event_timestamp}, \
				acctupdatetime = ${...event_timestamp}, \
				connectinfo_start = '%{Connect-Info}', \
				class = '%{Class}' \
			WHERE acctuniqueid = '%{Acct-Unique-Session-ID}' \
			AND acctstoptime IS NULL"
	}

	interim-update {
		query = "\
			UPDATE ${...acct_table1} \
			SET \
				framedipaddress = NULLIF('%{Framed-IP-Address}', ''), \
				framedipv6address = NULLIF('%{Framed-IPv6-Address}', ''), \
				framedipv6prefix = NULLIF('%{Framed-IPv6-Prefix}', ''), \
				framedinterfaceid = NULLIF('%{Framed-Interface-Id}', ''), \
				delegatedipv6prefix = NULLIF('%{Delegated-IPv6-Prefix}', ''), \
				acctsessiontime = '%{Acct-Session-Time}', \
				acctinputoctets = %{(((uint64) Acct-Input-Gigawords) << 32) | (uint64) Acct-Input-Octets}, \
				acctoutputoctets = %{(((uint64) Acct-Output-Gigawords) << 32) | (uint64) Acct-Output-Octets}, \
				class = '%{Class}' \
			WHERE acctuniqueid = '%{Acct-Unique-Session-ID}' \
			AND acctstoptime IS NULL"

		query = "\
			INSERT into ${...acct_table1} \
				(%{..column_list}) \
			VALUES(\
				'%{Acct-Session-Id}', \
				'%{Acct-Unique-Session-Id}', \
				'%{SQL-User-Name}', \
				'%{Realm}', \
				'%{NAS-IP-Address}', \
				'%{NAS-Port-ID || NAS-Port}', \
				'%{NAS-Port-Type}', \
				${...event_timestamp} - NUMTODSINTERVAL(%{Acct-Session-Time},'SECOND')", \
				${...event_timestamp}, \
				NULL, \
				'%{Acct-Session-Time}', \
				'%{Acct-Authentic}', \
				'%{Connect-Info}', \
				'', \
				'%{(((uint64) Acct-Input-Gigawords) << 32) | (uint64) Acct-Input-Octets}', \
				'%{(((uint64) Acct-Output-Gigawords) << 32) | (uint64) Acct-Output-Octets}', \
				'%{Called-Station-Id}', \
				'%{Calling-Station-Id}', \
				'', \
				'%{Service-Type}', \
				'%{Framed-Protocol}', \
				'%{Framed-IP-Address}', \
				'%{Framed-IPv6-Address}', \
				'%{Framed-IPv6-Prefix}', \
				'%{Framed-Interface-Id}', \
				'%{Delegated-IPv6-Prefix}', \
				'%{Class}')"
	}

	stop {
		query = "\
			UPDATE ${...acct_table2} \
			SET \
				acctstoptime = ${...event_timestamp}, \
				acctsessiontime = '%{Acct-Session-Time}', \
				acctinputoctets = '%{(((uint64) Acct-Input-Gigawords) << 32) | (uint64) Acct-Input-Octets}', \
				acctoutputoctets = '%{(((uint64) Acct-Output-Gigawords) << 32) | (uint64) Acct-Output-Octets}', \
				acctterminatecause = '%{Acct-Terminate-Cause}', \
				connectinfo_stop = '%{Connect-Info}', \
				class = '%{Class}' \
			WHERE acctuniqueid = '%{Acct-Unique-Session-ID}' \
			AND acctstoptime IS NULL"

		query = "\
			INSERT into ${...acct_table2}
				(${..column_list}) \
			VALUES(\
				'%{Acct-Session-Id}', \
				'%{Acct-Unique-Session-Id}', \
				'%{SQL-User-Name}', \
				'%{Realm}', \
				'%{NAS-IP-Address}', \
				'%{NAS-Port-ID || NAS-Port}', \
				'%{NAS-Port-Type}', \
				${...event_timestamp} - NUMTODSINTERVAL(%{Acct-Session-Time},'SECOND')", \
				${...event_timestamp}, \
				${...event_timestamp}, \
				'%{Acct-Session-Time}', \
				'%{Acct-Authentic}', \
				'', \
				'%{Connect-Info}', \
				'%{(((uint64) Acct-Input-Gigawords) << 32) | (uint64) Acct-Input-Octets}', \
				'%{(((uint64) Acct-Output-Gigawords) << 32) | (uint64) Acct-Output-Octets}', \
				'%{Called-Station-Id}', \
				'%{Calling-Station-Id}', \
				'%{Acct-Terminate-Cause}', \
				'%{Service-Type}', \
				'%{Framed-Protocol}', \
				'%{Framed-IP-Address}', \
				'%{Framed-IPv6-Address}', \
				'%{Framed-IPv6-Prefix}', \
				'%{Framed-Interface-Id}', \
				'%{Delegated-IPv6-Prefix}', \
				'%{Class}')"
	}
}

#######################################################################
# Authentication Logging Queries
#######################################################################
# send queries                - Insert some info after authentication
#######################################################################

send {
	# Write SQL queries to a logfile. This is potentially useful for bulk inserts
	# when used with the rlm_sql_null driver.
#	logfile = ${logdir}/post-auth.sql

	access-accept {
		query = "\
			INSERT INTO ${...postauth_table} \
				(username, pass, reply, authdate, class) \
			VALUES (\
				'%{User-Name}', \
				'%{User-Password || Chap-Password}', \
				'%{reply.Packet-Type}', \
				TO_TIMESTAMP('%S.%M','YYYY-MM-DDHH24:MI:SS.FF'), \
				'%{reply.Class}')"
	}

	access-reject {
		query = "${..access-accept.query}"
	}
}
