# -*- text -*-
#
#  main/mongo/queries.conf -- Mongo configuration queries
#
#  Note that as Mongo is a "schemaless" database, there is no
#  default schema.
#
#  Note also that the Mongo driver is a work in progress.  If it works
#  for you, great.  If the queries do not work, please send a patch.
#  But the FreeRADIUS team are not experts in Mongo, and cannot help
#  with creating Mongo queries.
#
#  $Id$

#######################################################################
#  Query config:  Username
#######################################################################
# This is the username that will get substituted, escaped, and added
# as attribute 'SQL-User-Name'.  '%{SQL-User-Name}' should be used
# below everywhere a username substitution is needed so you you can
# be sure the username passed from the client is escaped properly.
#
# Uncomment the next line, if you want the sql_user_name to mean:
#
#    Use Stripped-User-Name, if it's there.
#    Else use User-Name, if it's there,
#    Else use hard-coded string "none" as the user name.
#
#sql_user_name = "%{%{Stripped-User-Name}:-%{%{User-Name}:-none}}"
sql_user_name = "%{User-Name}"

# Safe characters list for sql queries. Everything else is replaced
# with their mime-encoded equivalents.
# The default list should be ok
#safe_characters = "@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_/{}()[]: \'"

#######################################################################
#  Query config:  Event-Timestamp
#######################################################################
# event_timestamp_epoch is the basis for the time inserted into
# accounting records. Typically this will be the Event-Timestamp of the
# accounting request, which is usually provided by a NAS.
#
# Uncomment the next line, if you want the timestamp to be based on the
# request reception time recorded by this server, for example if you
# distrust the provided Event-Timestamp.
#event_timestamp_epoch = "%l"
event_timestamp_epoch = "%{%(integer:%{Event-Timestamp}):-%l}"

# event_timestamp is the SQL snippet for converting an epoch timestamp
# to an SQL date.
event_timestamp = "${event_timestamp_epoch}"

#######################################################################
#  Authorization Queries
#######################################################################
#  These queries compare the check items for the user
#  in ${authcheck_table} and setup the reply items in
#  ${authreply_table}.  You can use any query/tables
#  you want, but the return data for each row MUST
#  be in the  following order:
#
#  0. Row ID (currently unused)
#  1. UserName/GroupName
#  2. Item Attr Name
#  3. Item Attr Value
#  4. Item Attr Operation
#######################################################################

#
# Aggregate query that return like for SQL standard N rows with columns <username>,<attribute>,<value>,<op>
#
# Example of input in 'authcheck_table' and 'authreply_table':
#
# {
#     username: 'bob',
#     attributes: [
#         {
#             _id: 0,
#             username: 'bob',
#             attribute: 'NAS-Port-Type',
#             value: 'Wireless-802.11',
#             op: ':='
#         },
#         {
#             _id: 1,
#             username: 'bob',
#             attribute: 'NAS-Port',
#             value: '123',
#             op: ':='
#         },
#         {
#             _id: 2,
#             username: 'bob',
#             attribute: 'Cache-TTL',
#             value: '456',
#             op: ':='
#         }
#     ]
# }
#
# Example of result:
#
# { '_id': 0, 'username': 'bob', 'attribute' : 'NAS-Port-Type', 'value' : 'Wireless-802.11', 'op' : ':=' }
# { '_id': 1, 'username': 'bob', 'attribute' : 'NAS-Port', 'value' : '123', 'op' : ':=' }
# { '_id': 2, 'username': 'bob', 'attribute' : 'Cache-TTL', 'value' : '456', 'op' : ':=' }
#
authorize_check_query = "db.${authcheck_table}.aggregate([ \
    {                                                      \
        '$match': {                                        \
            'username': '%{SQL-User-Name}'                 \
        }                                                  \
    },                                                     \
    {                                                      \
        '$unwind': '$attributes'                           \
    },                                                     \
    {                                                      \
        '$replaceRoot': {                                  \
            'newRoot': '$attributes'                       \
        }                                                  \
    }                                                      \
])"

authorize_reply_query = "db.${authreply_table}.aggregate([ \
    {                                                      \
        '$match': {                                        \
            'username': '%{SQL-User-Name}'                 \
        }                                                  \
    },                                                     \
    {                                                      \
        '$unwind': '$attributes'                           \
    },                                                     \
    {                                                      \
        '$replaceRoot': {                                  \
            'newRoot': '$attributes'                       \
        }                                                  \
    }                                                      \
])"

##################################################################

#
# Use these for case sensitive usernames.
#
group_membership_query = "db.${usergroup_table}.aggregate([ \
    {                                                       \
        '$match': {                                         \
            'username': '%{SQL-User-Name}'                  \
        }                                                   \
    },                                                      \
    {                                                       \
        '$project': {                                       \
            '_id': 0,                                       \
            'groupname': '$groupname'                       \
        }                                                   \
    }                                                       \
])"

authorize_group_check_query = "db.${groupcheck_table}.aggregate([ \
{                                                                 \
    '$match': {                                                   \
        'groupname': '%{${group_attribute}}'                      \
    }                                                             \
},                                                                \
{                                                                 \
    '$unwind': '$attributes'                                      \
},                                                                \
{                                                                 \
    '$replaceRoot': {                                             \
        'newRoot': '$attributes'                                  \
    }                                                             \
}                                                                 \
])"

authorize_group_reply_query = "db.${groupreply_table}.aggregate([ \
    {                                                             \
        '$match': {                                               \
            'groupname': '%{${group_attribute}}'                  \
        }                                                         \
    },                                                            \
    {                                                             \
        '$unwind': '$attributes'                                  \
    },                                                            \
    {                                                             \
        '$replaceRoot': {                                         \
            'newRoot': '$attributes'                              \
        }                                                         \
    }                                                             \
])"


#######################################################################
# Accounting and Post-Auth Queries
#######################################################################
# These queries insert/update accounting and authentication records.
# The query to use is determined by the value of 'reference'.
# This value is used as a configuration path and should resolve to one
# or more 'query's. If reference points to multiple queries, and a query
# fails, the next query is executed.
#
# Behaviour is identical to the old 1.x/2.x module, except we can now
# fail between N queries, and query selection can be based on any
# combination of attributes, or custom 'Acct-Status-Type' values.
#######################################################################

accounting {
    reference = "%{tolower:type.%{Acct-Status-Type}.query}"

    #
    # Write noSQL queries to a logfile. This is potentially useful for bulk inserts
    # when used with the rlm_sql_null driver.
    #
    #logfile = ${logdir}/accounting.js

    type {
        accounting-on {
            #
            #  "Bulk update" Accounting-On/Off strategy.
            #
            #  Immediately terminate all sessions associated with a
            #  given NAS.
            #
            #  Note: If a large number of sessions require closing
            #  then the bulk update may be take a long time to run
            #  and lock an excessive number of rows. See the
            #  strategy below for an alternative approach that does
            #  not touch the radacct session data.
            #
            query = "db.${....acct_table1}.findAndModify({ \
                        'query': {                                                                    \
                            'acctstoptime': null,                                                     \
                            'nasipaddress': '%{%{NAS-IPv6-Address}:-%{NAS-IP-Address}}',              \
                            'acctstarttime': {                                                        \
                                '$lt': ${....event_timestamp}                                         \
                            }                                                                         \
                        },                                                                            \
                        'update': {                                                                   \
                            '$set': {                                                                 \
                                'acctstoptime': '${....event_timestamp}',                             \
                                'acctsessiontime': {                                                  \
                                    '$subtract': [ '${....event_timestamp_epoch}', '$acctstarttime' ] \
                                },                                                                    \
                                'acctterminatecause': '%{%{Acct-Terminate-Cause}:-NAS-Reboot}',       \
                                'class': '0x%{hex:%{Class}}',                                         \
                                'framedipaddress': '%{Framed-IP-Address}',                            \
                                'update_date':  {                                                     \
                                    '$date': {                                                        \
                                        '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}'           \
                                    }                                                                 \
                                },                                                                    \
                                'start_time': '%{Packet-Original-Timestamp}'                          \
                            },                                                                        \
                            '$push': {                                                                \
                                'events_data': {                                                      \
                                    'event_id': '%{sha2_256:%{tolower:%{Calling-Station-Id}}}',       \
                                    'event_type': 'Accounting-On',                                    \
                                    'event_time': '%{Packet-Original-Timestamp}',                     \
                                    'creation_date': {                                                \
                                        '$date': {                                                    \
                                            '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}'       \
                                        }                                                             \
                                    }                                                                 \
                                }                                                                     \
                            },                                                                        \
                            '$setOnInsert': {                                                         \
                                'pool_name': '%{control.IP-Pool.Name}',                               \
                                'closed': false,                                                      \
                                'update_counter': 0,                                                  \
                                'creation_date': {                                                    \
                                    '$date': {                                                        \
                                        '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}'           \
                                    }                                                                 \
                                }                                                                     \
                            }                                                                         \
                        },                                                                            \
                        'upsert': true                                                                \
                    })"


            #  "Lightweight" Accounting-On/Off strategy.
            #
            #  Record the reload time of the NAS and let the
            #  administrator actually close the sessions in radacct
            #  out-of-band, if desired.
            #
            #  To enable this strategy, just change the previous
            #  query to "-query", and this one to "query".  The
            #  previous one will be ignored, and this one will be
            #  enabled.
            #
            -query = "db.nasreload.findAndModify({                                       \
                        'query': {                                                       \
                            'nasipaddress': '%{%{NAS-IPv6-Address}:-%{NAS-IP-Address}}', \
                            'reloadtime': ${....event_timestamp}                         \
                        },                                                               \
                        'update': {                                                      \
                            'nasipaddress': '%{%{NAS-IPv6-Address}:-%{NAS-IP-Address}}', \
                            'reloadtime': ${....event_timestamp}                         \
                        },                                                               \
                        'upsert': true                                                   \
                    })"
            #
            #  If there are no open user sessions, then the previous query
            #  will return "no rows updated".  The server will then fall through
            #  to the next query, which is just "yes, that's fine".
            #
            query = "db.${....acct_table1}.findAndModify({})"
        }
        # End On

        start {
            #
            #  Insert a new record into the sessions table
            #
            query = "db.${....acct_table1}.findAndModify({ \
                        'query': {                                                              \
                            'class': '0x%{hex:%{Class}}'                                        \
                        },                                                                      \
                        'update': {                                                             \
                            '$set':{                                                            \
                                'acctsessionid': '%{Acct-Session-Id}',                          \
                                'acctuniqueid': '%{Acct-Unique-Session-Id}',                    \
                                'username': '%{SQL-User-Name}',                                 \
                                'realm': '%{Realm}',                                            \
                                'nasipaddress': '%{%{NAS-IPv6-Address}:-%{NAS-IP-Address}}}',   \
                                'nasportid': '%{%{NAS-Port-ID}:-%{NAS-Port}}',                  \
                                'nasporttype': '%{NAS-Port-Type}',                              \
                                'acctstarttime': '${....event_timestamp}',                      \
                                'acctupdatetime': '${....event_timestamp}',                     \
                                'acctstoptime': '0',                                            \
                                'acctsessiontime': '0',                                         \
                                'acctauthentic': '%{Acct-Authentic}',                           \
                                'connectinfo_start': '%{Connect-Info}',                         \
                                'connectinfo_stop': '',                                         \
                                'acctinputoctets': '0',                                         \
                                'acctoutputoctets': '0',                                        \
                                'calledstationid': '%{Called-Station-Id}',                      \
                                'callingstationid': '%{Calling-Station-Id}',                    \
                                'acctterminatecause': '',                                       \
                                'servicetype': '%{Service-Type}',                               \
                                'framedprotocol': '%{Framed-Protocol}',                         \
                                'framedipaddress': '%{Framed-IP-Address}',                      \
                                'framedipv6address': '%{Framed-IPv6-Address}',                  \
                                'framedipv6prefix': '%{Framed-IPv6-Prefix}',                    \
                                'framedinterfaceid': '%{Framed-Interface-Id}',                  \
                                'delegatedipv6prefix': '%{Delegated-IPv6-Prefix}',              \
                                'class': '0x%{hex:%{Class}}'                                    \
                            },                                                                  \
                            '$push': {                                                          \
                                'events_data': {                                                \
                                    'event_id': '%{sha2_256:%{tolower:%{Calling-Station-Id}}}', \
                                    'event_type': 'Start',                                      \
                                    'event_time': '%l',                                         \
                                    'creation_date': {                                          \
                                        '$date': {                                              \
                                            '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}' \
                                        }                                                       \
                                    }                                                           \
                                }                                                               \
                            }                                                                   \
                        },                                                                      \
                        'upsert':true                                                           \
                    })"
        }
        # End Start

        interim-update {
            #
            #  Update an existing session and calculate the interval
            #  between the last data we received for the session and this
            #  update. This can be used to find stale sessions.
            #
            query = "db.${....acct_table1}.findAndModify({                          \
                        'query': {                                                  \
                            'acctuniqueid': '%{Acct-Unique-Session-Id}'             \
                        },                                                          \
                        'update': {                                                 \
                            '$set':{                                                \
                                'acctupdatetime': '${....event_timestamp}',         \
                                'acctsessionid': '%{Acct-Session-Id}',              \
                                'acctinterval': 0,                                  \
                                'framedipaddress': '%{Framed-IP-Address}',          \
                                'framedipv6address': '%{Framed-IPv6-Address}',      \
                                'framedipv6prefix': '%{Framed-IPv6-Prefix}',        \
                                'framedinterfaceid': '%{Framed-Interface-Id}',      \
                                'delegatedipv6prefix': '%{Delegated-IPv6-Prefix}',  \
                                'acctsessiontime': '%{%{Acct-Session-Time}:-null}', \
                                'acctinputoctets': '%{%{Acct-Input-Octets}:-0}',    \
                                'acctoutputoctets': '%{%{Acct-Output-Octets}:-0}',  \
                                'class': '0x%{hex:%{Class}}'                                    \
                            },                                                                  \
                            '$push': {                                                          \
                                'events_data': {                                                \
                                    'event_id': '%{sha2_256:%{tolower:%{Calling-Station-Id}}}', \
                                    'event_type': 'Update',                                     \
                                    'event_time': '%l',                                         \
                                    'creation_date': {                                          \
                                        '$date': {                                              \
                                            '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}' \
                                        }                                                       \
                                    }                                                           \
                                }                                                               \
                            }                                                                   \
                        },                                                                      \
                        'upsert':true                                                           \
                    })"
        }
        # End Interim-Update

        stop {
            #
            #  Session has terminated, update the stop time and statistics.
            #
            query = "db.${....acct_table1}.findAndModify({                          \
                        'query': {                                                  \
                            'acctuniqueid': '%{Acct-Unique-Session-Id}'             \
                        },                                                          \
                        'update': {                                                 \
                            '$set':{                                                \
                                'acctstoptime': '${....event_timestamp}',           \
                                'acctsessionid': '%{Acct-Session-Id}',              \
                                'acctsessiontime': '%{%{Acct-Session-Time}:-%{Packet-Original-Timestamp}}', \
                                'acctinputoctets': '%{%{Acct-Input-Octets}:-0}',    \
                                'acctoutputoctets': '%{%{Acct-Output-Octets}:-0}',  \
                                'acctterminatecause': '%{Acct-Terminate-Cause}',    \
                                'connectinfo_stop': '%{Connect-Info}',              \
                                'class': '0x%{hex:%{Class}}'                                    \
                            },                                                                  \
                            '$push': {                                                          \
                                'events_data': {                                                \
                                    'event_id': '%{sha2_256:%{tolower:%{Calling-Station-Id}}}', \
                                    'event_type': 'Stop',                                       \
                                    'event_time': '%l',                                         \
                                    'creation_date': {                                          \
                                        '$date': {                                              \
                                            '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}' \
                                        }                                                       \
                                    }                                                           \
                                }                                                               \
                            }                                                                   \
                        },                                                                      \
                        'upsert':true                                                           \
                    })"
        }
        # End Stop
    }
}


#######################################################################
# Authentication Logging Queries
#######################################################################
# postauth_query                - Insert some info after authentication
#######################################################################

post-auth {
    query = "db.post_auth.findAndModify({ \
        'query': { \
            'calling_station_id': '%{Calling-Station-Id}', \
            'nas_ip': '%{NAS-Identifier}' \
        }, \
        'update': { \
            '$set': { \
                'update_date':  { '$date': { '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}' } }, \
                'last_event_ts': '%{Packet-Original-Timestamp}' \
            }, \
            '$inc': { \
                'reject_counter': 1 \
            }, \
            '$setOnInsert': { \
                'calling_station_id': '%{Calling-Station-Id}', \
                'nas_ip': '%{NAS-Identifier}', \
                'creation_date': { '$date': { '$numberLong': '%{expr: (%l * 1000) + (%M / 1000)}' } } \
            } \
        }, \
        'upsert': true \
    })"
}
