/*
 *  The detectChanges function looks at the last git commit and
 *  searches for changes to "redhat/freeradius.spec" or anything
 *  in the "debian" directory.  If it finds any changes to those
 *  files it returns the string " --no-cache " which can be fed to
 *  a docker build command to tell docker to rebuild the image
 *  from scratch so that it can pick up any new dependencies
 *  specified in those package manifest files.
 */

def detectChanges() {
	def string = ""
	def changeLogSets = currentBuild.changeSets

	for (int i = 0; i < changeLogSets.size(); i++) {
		def entries = changeLogSets[i].items

		for (int j = 0; j < entries.length; j++) {
			def entry = entries[j]
			def files = new ArrayList(entry.affectedFiles)

			for (int k = 0; k < files.size(); k++) {
				def file = files[k]

				if (file.path =~ /(^debian\/.*)|(redhat\/freeradius.spec)/) {
					echo "changes in file ${file.path}, passing --no-cache flag to docker build"
					string = " --no-cache "
					return string
				}
			}
		}
	}
	return string
}


/*
 *  The buildClosures function is the core function of the script
 *  and uses function currying to be able to pass multiple
 *  dynamically generated jenkins build commands into a jenkins
 *  parallel block. This function ensures that the docker image is
 *  built and builds FreeRADIUS packages inside the docker image.
 */

def buildClosures(args) {
	println args.inspect()

	def platforms = args.platforms
	def source = args.source
	def branch = args.branch
	def package_version = args.package_version
	def package_release = args.package_release
	def use_commit = args.use_commit
	def server_dir = args.server_dir ?: "."

	def closures = [:]
	for (value in platforms) {

		closures[value] = {platform ->
			stage("build-${platform}") {
				docker.build("${platform}-test", "-f " + server_dir + "/scripts/jenkins/${platform}/Dockerfile " + server_dir + "/scripts/jenkins/${platform}").inside {

					checkout([$class: 'GitSCM',
						userRemoteConfigs: [
							[url: source]
						],
						branches: [
							[name: branch]
						],
						extensions: [
							[$class: 'CleanBeforeCheckout'],
							[$class: 'RelativeTargetDirectory',
								relativeTargetDir: "${platform}/build"
							],
							[$class: 'CloneOption',
								depth: 0,
								noTags: false,
								reference: '',
								shallow: false
							]
						],
						submoduleCfg: []
					])

					sh "cat /etc/os-release || cat /etc/redhat-release"

					def commit_num = "0"
					if (use_commit) {
						commit_num = readFile("./build-number").trim()
					}


					dir("${platform}/build/") {

						/*
						 *  Build up the package version number:
						 *    version: [ VERSION [+GITNUM] ]
						 *    release: -[ RELEASE ]
						 */

						def version = package_version
						if (version.length() == 0) {
							version = sh (script: "cat VERSION", returnStdout: true).trim()
						}

						if (use_commit) {
							version = version + "+" + commit_num
						}

						def release = package_release ?: "1"

						if (platform.contains("centos")) {
							sh 'mkdir -p rpmbuild/{SOURCES,SPECS,BUILD,BUILDROOT,RPMS,SRPMS}'
							sh 'tar -j -c --transform "s/./freeradius-server-' + version + '/" --exclude ".git" --exclude "rpmbuild" -f rpmbuild/SOURCES/freeradius-server-' + version + '.tar.bz2 .'
							sh 'for file in $(grep "^Source...:" redhat/freeradius.spec | cut -d" " -f2) ; do cp redhat/$file rpmbuild/SOURCES/$file ; done'

							sh 'sed -i -e "s/^Version:.*$/Version: ' + version + '/" redhat/freeradius.spec'
							sh 'sed -i -e "s/^Release:.*$/Release: ' + release + '/" redhat/freeradius.spec'

							sh 'rpmbuild --define "_topdir $(pwd)/rpmbuild" -bb redhat/freeradius.spec'
						} else {
							def commit_msg = sh (script: "git log --oneline -1 \$GIT_COMMIT", returnStdout: true).trim()
							sh "dch -b -v ${version}-${release} \"${commit_msg}\""

							sh 'make deb'
						}
					}

				}
			}
			echo platform.toString()
		}.curry(value)
	}
	closures
}


/*
 *  Find the number of commits since the previous release and
 *  write out to a file, "build-number". This is used in packages
 *  so that new commits don't create packages with the same
 *  version number.
 */

def genBuildNumber(source, file) {
	sh "(cd \"${source}\" && git describe --tags --long --match 'release_*' --match 'branch_*' | sed -e \'s/^.*-\\([0-9]*\\)-g[0-9a-f]*/\\1/\') > \"${file}\""
}

return this
