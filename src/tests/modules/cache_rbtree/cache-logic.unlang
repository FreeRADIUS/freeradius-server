#
#  PRE:
#
update {
	&request:Tmp-String-0 := 'testkey'
}


#
# 0.  Basic store and retrieve
#
update control {
	&control:Tmp-String-1 := 'cache me'
}

cache.add
if (!ok) {
	test_fail
}
else {
	test_pass
}

# 1. Check the module didn't perform a merge
if (&request:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

# 2. Check status-only works correctly (should return ok and consume attribute)
cache.status
if (!ok) {
	test_fail
}
else {
	test_pass
}


# 3. Retrieve the entry (should be copied to request list)
cache.lookup
if (!updated) {
	test_fail
}
else {
	test_pass
}

# 4.
if (&request:Tmp-String-1 != &control:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

# 5. Retrieving the entry should not expire it
update request {
	&Tmp-String-1 !* ANY
}

cache.lookup
if (!updated) {
	test_fail
}
else {
	test_pass
}

# 6.
if (&request:Tmp-String-1 != &control:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

# 7. Delete the entry
cache.delete
if (!ok) {
	test_fail
}
else {
	test_pass
}

# 8. Check status-only works correctly (should return notfound and consume attribute)
cache.status
if (!notfound) {
	test_fail
}
else {
	test_pass
}

# 9. Check merge-only works correctly (should return notfound and consume attribute)
cache.merge
if (!notfound) {
	test_fail
}
else {
	test_pass
}

# 10. ...and check the entry wasn't recreated
cache.status
if (!notfound) {
	test_fail
}
else {
	test_pass
}

# 11. This should still allow the creation of a new entry
update control {
	&Cache-TTL := -1
}
cache.add
if (!ok) {
	test_fail
}
else {
	test_pass
}

# 12. We have nothing to do if it is ready added.
cache.add
if (!noop) {
	test_fail
}
else {
	test_pass
}

# 13.
if (&Cache-TTL) {
	test_fail
}
else {
	test_pass
}

# 14.
if (&request:Tmp-String-1 != &control:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

update control {
	&Tmp-String-1 := 'cache me2'
}

# 15. Updating the Cache-TTL shouldn't make things go boom (we can't really check if it works)
update control {
	&Cache-TTL := 30
}
cache.merge
if (!updated) {
	test_fail
}
else {
	test_pass
}

# 16. Request Tmp-String-1 shouldn't have been updated yet
if (&request:Tmp-String-1 == &control:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

# 17. Check that a new entry is created
update control {
	&Cache-TTL := -1
}
cache.merge
if (!updated) {
	test_fail
}
else {
	test_pass
}


# 18.
cache.lookup
if (!updated) {
	test_fail
}
else {
	test_pass
}

# 19. Request Tmp-String-1 should now have been updated
if (&request:Tmp-String-1 == &control:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

# 20. Check cache.merge.new (should update current request)
update control {
	&Tmp-String-1 := 'cache me3'
	&Cache-TTL := -1
}
cache.merge.new
if (!updated) {
	test_fail
}
else {
	test_pass
}

# 21. Request Tmp-String-1 should now have been updated
if (&request:Tmp-String-1 != &control:Tmp-String-1) {
	test_fail
}
else {
	test_pass
}

# 22. Check Cache-Entry-Hits is updated as we expect
if (&request:Cache-Entry-Hits != 0) {
	test_fail
}
else {
	test_pass
}

cache.lookup
if (&request:Cache-Entry-Hits != 1) {
	test_fail
}
else {
	test_pass
}

