server load-generator {

    namespace = radius

    listen load {
        #
		#  The main module is the proto module, even though we're
		#  operating in the RADIUS namespace.
		#
        handler = load

        #
		#  This is a valid Packet-Type for the current `namespace`
		#
		type = Access-Request

        #
        # (Optional) and as indicated in the source code:
	    #   For performance tweaking.  NOT for normal humans.
	    #
        # max_packet_size = 4096
        # num_messages = 1
        # priority       = 0

        #
		#  For now, only 'step' transport is available.
		#
        # process by proto_load_step.c
        #####################################################################
        transport = step
        step {

            # - filename (required)
            #     Path to the file containing the template packet / attributes to send.
            #     Must exist, be readable, and non-empty.
            # - csv (optional)
            #     Path to a CSV file where per-socket stats will be written periodically (optional).
            # - max_attributes
            #     Maximum number of attributes to decode from the input packet.
            #     Default: RADIUS_MAX_ATTRIBUTES.
            # - start_pps
            #     Initial packets-per-second rate for the generator. (Field load.start_pps.)
            # - max_pps
            #     Maximum PPS the generator will ramp up to. (load.max_pps.)
            # - duration
            #     Duration (in seconds) of the load run at each step / overall, depending on how you drive it. (load.duration.)
            # - step
            #     Increment step for PPS between adjustments (e.g. increase by N PPS each interval). (load.step.)
            # - max_backlog
            #     Maximum backlog in milliseconds, mapped to load.milliseconds – effectively a cap on outstanding work / queue depth in time.
            # - parallel
            #     Degree of parallelism (how many generator threads/flows). (load.parallel.)
            # - repeat
            #     Boolean: whether to repeat the sequence from filename when it reaches the end. (repeat in proto_load_step_t.)

            filename = ${confdir}/load-generator-packets/packet.conf

            # optional CSV stats output file
            csv = ${confdir}/stats/load-generator-client-stats.csv

            #
            # Safety limit on attributes per packet
            #
            max_attributes = 64

            #
            # Load profile for this step
            #
            # start_pps: initial packets per second
            # max_pps  : maximum packets per second we’ll ramp to
            # duration : how long to run this step (seconds)
            # step     : increment in PPS per "tick" (0 = flat load)
            #
            start_pps = $ENV{TEST_CONF_START_PPS}
            max_pps   = $ENV{TEST_CONF_MAX_PPS}
            duration  = $ENV{TEST_CONF_DURATION}
            #start_pps = 1
            #max_pps = 1
            #duration = 2

            #
			#  How big of a packet/s step to jump after running each test.
			#
            step = $ENV{TEST_CONF_STEP}
            #step = 1

            #
			#  We don't want to overload the server.  If
			#  the server cannot process packets quickly
			#  enough, we will get a backlog of
			#  unprocessed packets.  If the backlog gets
			#  too high, then the load generator will
			#  temporarily stop sending packets.  Once the
			#  backlog is low enough, it will continue.
			#
			max_backlog = $ENV{TEST_CONF_MAX_BACKLOG}
            #max_backlog	= 1000

			#
			#  How many packets to send immediately in
			#  parallel, without waiting for a response.
			#  When a reply is received, a new request may
			#  be sent.
			#
            parrallel = $ENV{TEST_CONF_PARALLEL}
            #parallel = 1

            num_messages = $ENV{TEST_CONF_NUM_MESSAGES}
            #num_messages = 10

            repeat = no
        }

    }

    # Using same config as what the "default" virtual server would use.
	listen authentication {
		type = Access-Request
		type = Status-Server
		transport = udp
		require_message_authenticator = auto
		limit_proxy_state = auto

		limit {
			max_clients = 256
			max_connections = 256
			idle_timeout = 60.0
			dynamic_timeout = 600.0
			nak_lifetime = 30.0
			cleanup_delay = 5.0
		}

		udp {
			ipaddr = *
			port = 1812
			networks {
				allow = 127/8
				allow = 192.0.2/24
			}
		}

		tcp {
			ipaddr = *
			port = 1812
			networks {
				allow = 127/8
				allow = 192.0.2/24
			}
		}
	}

	listen authentication {
		type = Access-Request
		type = Status-Server
		transport = tcp

		tcp {
			ipaddr = *
			port = 1812
			networks {
				allow = 127/8
				allow = 192.0.2/24
			}
		}
	}

	listen accounting {
		type = Accounting-Request
		transport = udp

		udp {
			ipaddr = *
			port = 1813
		}
	}

	client localhost {
		shortname = sample
		ipaddr = 192.0.2.1
		secret = testing123
	}

    listen statusserver {
		transport = udp
		udp {
			ipaddr = 0.0.0.0
			port = 1820
		}

		type = Status-Server
	}

    #
	#  Receive a Status-Server packet
	#
    recv Status-Server {
        # stats module required to have access to the Status-Server's global statistics
        stats

        %linelog_test_framework("loadgen-recv-status-server - INFO - reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server: %{reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server || 0}")
        %linelog_test_framework("loadgen-recv-status-server - INFO - reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request: %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request || 0}")
        %linelog_test_framework("loadgen-recv-status-server - INFO - reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept: %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept || 0}")
        %linelog_test_framework("loadgen-recv-status-server - INFO - reply.FreeRADIUS.Stats4.Packet-Counters.Access-Reject: %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Reject || 0}")

        # The Stats Module documentation explicitly states: "When listed in a recv Status-Server section, it will add global server statistics to the packet,
        # hence the reason "reply.FreeRADIUS.Stats4" is used below.
        if ((reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept - reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server) != reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request) {
            %linelog_test_framework("loadgen-recv-status-server - ERROR - expected vs actual stat missmatch, reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request = %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request}, reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept = %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept}, reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server: %{reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server}")
        }

        if (reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request == (reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept - reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server)) {
            %linelog_test_framework("loadgen-recv-status-server - INFO - %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request} requests processed successfully, reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request = %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Request}, reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept = %{reply.FreeRADIUS.Stats4.Packet-Counters.Access-Accept}, reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server = %{reply.FreeRADIUS.Stats4.Packet-Counters.Status-Server}")
        }

        ok
    }

    #
    #  The rest of the recv/send sections are protocol specific, and are
    #  taken from the `namespace`.
    #

    recv Access-Request {
        # Optional: use unlang to modify packet before calling radius module to send
        # requests to the upstream RADIUS server(s).

        # The Auth-Type value is specifically set to use the load-generator-proxy authenticate logic
        control.Auth-Type := "load-generator-proxy"
    }

    authenticate load-generator-proxy {
        # The Auth-Type value is specifically set to use the load-generator-proxy authenticate logic
        # The radius module udp { ... } configuration defines where the requests are sent; refer
        # to mods-available/radius for that configuration.
        redundant-load-balance {
			radius-module-homeserver1
			radius-module-homeserver2
            radius-module-homeserver3
            radius-module-homeserver4
            radius-module-homeserver5
		}
    }

    send Access-Request {
        stats
        ok
    }

    recv Access-Accept {
        stats
        ok
    }


    send Access-Accept {
        #%linelog_test_framework("load-generator: send Access-Accept STARTED")
        stats
        ok
    }

    send Access-Reject {
        #%linelog_test_framework("load-generator: send Access-Reject STARTED")
        stats
        ok
    }

    # Accounting sections currently based on "default" virtual server config
	recv Accounting-Request {
		if (!Event-Timestamp) {
			Event-Timestamp := %time.request() - %{Acct-Delay-Time || 0}
		}
		acct_unique
		files_accounting
	}

#    recv Accounting-Request {
#        # Optional: use unlang to modify packet before calling radius module to send
#        # requests to the upstream RADIUS server(s).
#
#		if (!Event-Timestamp) {
#			Event-Timestamp := %time.request() - %{Acct-Delay-Time || 0}
#		}
#
#		redundant-load-balance {
#			homeserver1_acct
#			homeserver2_acct
#           homeserver3_acct
#           homeserver4_acct
#           homeserver5_acct
#		}
#
#		ok
#	}

	accounting Start {
	}

	accounting Stop {
	}

	accounting Interim-Update {
	}

	accounting Accounting-On {
	}

	accounting Accounting-Off {
	}

	accounting Failed {
	}

	send Accounting-Response {
		detail
		attr_filter.accounting_response
	}

}
